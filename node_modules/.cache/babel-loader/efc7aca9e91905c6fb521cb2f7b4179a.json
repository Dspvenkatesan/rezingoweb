{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { Constants, SSOTypes, ServerHashParamKeys } from \"./Constants\";\nimport { ScopeSet } from \"../ScopeSet\";\nimport { StringUtils } from \"./StringUtils\";\nimport { CryptoUtils } from \"./CryptoUtils\";\n/**\n * @hidden\n */\n\nvar UrlUtils =\n/** @class */\nfunction () {\n  function UrlUtils() {}\n  /**\n   * generates the URL with QueryString Parameters\n   * @param scopes\n   */\n\n\n  UrlUtils.createNavigateUrl = function (serverRequestParams) {\n    var str = this.createNavigationUrlString(serverRequestParams);\n    var authEndpoint = serverRequestParams.authorityInstance.AuthorizationEndpoint; // if the endpoint already has queryparams, lets add to it, otherwise add the first one\n\n    if (authEndpoint.indexOf(\"?\") < 0) {\n      authEndpoint += \"?\";\n    } else {\n      authEndpoint += \"&\";\n    }\n\n    var requestUrl = \"\" + authEndpoint + str.join(\"&\");\n    return requestUrl;\n  };\n  /**\n   * Generate the array of all QueryStringParams to be sent to the server\n   * @param scopes\n   */\n\n\n  UrlUtils.createNavigationUrlString = function (serverRequestParams) {\n    var scopes = ScopeSet.appendDefaultScopes(serverRequestParams.scopes);\n    var str = [];\n    str.push(\"response_type=\" + serverRequestParams.responseType);\n    str.push(\"scope=\" + encodeURIComponent(ScopeSet.parseScope(scopes)));\n    str.push(\"client_id=\" + encodeURIComponent(serverRequestParams.clientId));\n    str.push(\"redirect_uri=\" + encodeURIComponent(serverRequestParams.redirectUri));\n    str.push(\"state=\" + encodeURIComponent(serverRequestParams.state));\n    str.push(\"nonce=\" + encodeURIComponent(serverRequestParams.nonce));\n    str.push(\"client_info=1\");\n    str.push(\"x-client-SKU=\" + serverRequestParams.xClientSku);\n    str.push(\"x-client-Ver=\" + serverRequestParams.xClientVer);\n\n    if (serverRequestParams.promptValue) {\n      str.push(\"prompt=\" + encodeURIComponent(serverRequestParams.promptValue));\n    }\n\n    if (serverRequestParams.claimsValue) {\n      str.push(\"claims=\" + encodeURIComponent(serverRequestParams.claimsValue));\n    }\n\n    if (serverRequestParams.queryParameters) {\n      str.push(serverRequestParams.queryParameters);\n    }\n\n    if (serverRequestParams.extraQueryParameters) {\n      str.push(serverRequestParams.extraQueryParameters);\n    }\n\n    str.push(\"client-request-id=\" + encodeURIComponent(serverRequestParams.correlationId));\n    return str;\n  };\n  /**\n   * Returns current window URL as redirect uri\n   */\n\n\n  UrlUtils.getCurrentUrl = function () {\n    return window.location.href.split(\"?\")[0].split(\"#\")[0];\n  };\n  /**\n   * Returns given URL with query string removed\n   */\n\n\n  UrlUtils.removeHashFromUrl = function (url) {\n    return url.split(\"#\")[0];\n  };\n  /**\n   * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\n   * @param href The url\n   * @param tenantId The tenant id to replace\n   */\n\n\n  UrlUtils.replaceTenantPath = function (url, tenantId) {\n    var lowerCaseUrl = url.toLowerCase();\n    var urlObject = this.GetUrlComponents(lowerCaseUrl);\n    var pathArray = urlObject.PathSegments;\n\n    if (tenantId && pathArray.length !== 0 && (pathArray[0] === Constants.common || pathArray[0] === SSOTypes.ORGANIZATIONS || pathArray[0] === SSOTypes.CONSUMERS)) {\n      pathArray[0] = tenantId;\n    }\n\n    return this.constructAuthorityUriFromObject(urlObject, pathArray);\n  };\n\n  UrlUtils.constructAuthorityUriFromObject = function (urlObject, pathArray) {\n    return this.CanonicalizeUri(urlObject.Protocol + \"//\" + urlObject.HostNameAndPort + \"/\" + pathArray.join(\"/\"));\n  };\n  /**\n   * Checks if an authority is common (ex. https://a:b/common/)\n   * @param url The url\n   * @returns true if authority is common and false otherwise\n   */\n\n\n  UrlUtils.isCommonAuthority = function (url) {\n    var authority = this.CanonicalizeUri(url);\n    var pathArray = this.GetUrlComponents(authority).PathSegments;\n    return pathArray.length !== 0 && pathArray[0] === Constants.common;\n  };\n  /**\n   * Checks if an authority is for organizations (ex. https://a:b/organizations/)\n   * @param url The url\n   * @returns true if authority is for  and false otherwise\n   */\n\n\n  UrlUtils.isOrganizationsAuthority = function (url) {\n    var authority = this.CanonicalizeUri(url);\n    var pathArray = this.GetUrlComponents(authority).PathSegments;\n    return pathArray.length !== 0 && pathArray[0] === SSOTypes.ORGANIZATIONS;\n  };\n  /**\n   * Checks if an authority is for consumers (ex. https://a:b/consumers/)\n   * @param url The url\n   * @returns true if authority is for  and false otherwise\n   */\n\n\n  UrlUtils.isConsumersAuthority = function (url) {\n    var authority = this.CanonicalizeUri(url);\n    var pathArray = this.GetUrlComponents(authority).PathSegments;\n    return pathArray.length !== 0 && pathArray[0] === SSOTypes.CONSUMERS;\n  };\n  /**\n   * Parses out the components from a url string.\n   * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\n   */\n\n\n  UrlUtils.GetUrlComponents = function (url) {\n    if (!url) {\n      throw \"Url required\";\n    } // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\n\n\n    var regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\n    var match = url.match(regEx);\n\n    if (!match || match.length < 6) {\n      throw \"Valid url required\";\n    }\n\n    var urlComponents = {\n      Protocol: match[1],\n      HostNameAndPort: match[4],\n      AbsolutePath: match[5]\n    };\n    var pathSegments = urlComponents.AbsolutePath.split(\"/\");\n    pathSegments = pathSegments.filter(function (val) {\n      return val && val.length > 0;\n    }); // remove empty elements\n\n    urlComponents.PathSegments = pathSegments;\n\n    if (match[6]) {\n      urlComponents.Search = match[6];\n    }\n\n    if (match[8]) {\n      urlComponents.Hash = match[8];\n    }\n\n    return urlComponents;\n  };\n  /**\n   * Given a url or path, append a trailing slash if one doesnt exist\n   *\n   * @param url\n   */\n\n\n  UrlUtils.CanonicalizeUri = function (url) {\n    if (url) {\n      var lowerCaseUrl = url.toLowerCase();\n\n      if (!UrlUtils.endsWith(lowerCaseUrl, \"/\")) {\n        lowerCaseUrl += \"/\";\n      }\n\n      return lowerCaseUrl;\n    }\n\n    return url;\n  };\n  /**\n   * Checks to see if the url ends with the suffix\n   * Required because we are compiling for es5 instead of es6\n   * @param url\n   * @param str\n   */\n  // TODO: Rename this, not clear what it is supposed to do\n\n\n  UrlUtils.endsWith = function (url, suffix) {\n    if (!url || !suffix) {\n      return false;\n    }\n\n    return url.indexOf(suffix, url.length - suffix.length) !== -1;\n  };\n  /**\n   * Utils function to remove the login_hint and domain_hint from the i/p extraQueryParameters\n   * @param url\n   * @param name\n   */\n\n\n  UrlUtils.urlRemoveQueryStringParameter = function (url, name) {\n    if (StringUtils.isEmpty(url)) {\n      return url;\n    }\n\n    var updatedUrl = url;\n    var regex = new RegExp(\"(\\\\&\" + name + \"=)[^\\&]+\");\n    updatedUrl = url.replace(regex, \"\"); // name=value&\n\n    regex = new RegExp(\"(\" + name + \"=)[^\\&]+&\");\n    updatedUrl = url.replace(regex, \"\"); // name=value\n\n    regex = new RegExp(\"(\" + name + \"=)[^\\&]+\");\n    updatedUrl = url.replace(regex, \"\");\n    return updatedUrl;\n  };\n  /**\n   * @hidden\n   * @ignore\n   *\n   * Returns the anchor part(#) of the URL\n   */\n\n\n  UrlUtils.getHashFromUrl = function (urlStringOrFragment) {\n    var hashIndex1 = urlStringOrFragment.indexOf(\"#\");\n    var hashIndex2 = urlStringOrFragment.indexOf(\"#/\");\n\n    if (hashIndex2 > -1) {\n      return urlStringOrFragment.substring(hashIndex2 + 2);\n    } else if (hashIndex1 > -1) {\n      return urlStringOrFragment.substring(hashIndex1 + 1);\n    }\n\n    return urlStringOrFragment;\n  };\n  /**\n   * @hidden\n   * Check if the url contains a hash with known properties\n   * @ignore\n   */\n\n\n  UrlUtils.urlContainsHash = function (urlString) {\n    var parameters = UrlUtils.deserializeHash(urlString);\n    return parameters.hasOwnProperty(ServerHashParamKeys.ERROR_DESCRIPTION) || parameters.hasOwnProperty(ServerHashParamKeys.ERROR) || parameters.hasOwnProperty(ServerHashParamKeys.ACCESS_TOKEN) || parameters.hasOwnProperty(ServerHashParamKeys.ID_TOKEN);\n  };\n  /**\n   * @hidden\n   * Returns deserialized portion of URL hash\n   * @ignore\n   */\n\n\n  UrlUtils.deserializeHash = function (urlFragment) {\n    var hash = UrlUtils.getHashFromUrl(urlFragment);\n    return CryptoUtils.deserialize(hash);\n  };\n  /**\n   * @ignore\n   * @param {string} URI\n   * @returns {string} host from the URI\n   *\n   * extract URI from the host\n   */\n\n\n  UrlUtils.getHostFromUri = function (uri) {\n    // remove http:// or https:// from uri\n    var extractedUri = String(uri).replace(/^(https?:)\\/\\//, \"\");\n    extractedUri = extractedUri.split(\"/\")[0];\n    return extractedUri;\n  };\n\n  return UrlUtils;\n}();\n\nexport { UrlUtils };","map":null,"metadata":{},"sourceType":"module"}