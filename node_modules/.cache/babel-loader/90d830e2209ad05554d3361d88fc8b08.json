{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { __spreadArrays } from \"tslib\";\nimport { ClientConfigurationError } from \"./error/ClientConfigurationError\";\nimport { Constants } from \"./utils/Constants\";\n\nvar ScopeSet =\n/** @class */\nfunction () {\n  function ScopeSet() {}\n  /**\n   * Check if there are dup scopes in a given request\n   *\n   * @param cachedScopes\n   * @param scopes\n   */\n  // TODO: Rename this, intersecting scopes isn't a great name for duplicate checker\n\n\n  ScopeSet.isIntersectingScopes = function (cachedScopes, scopes) {\n    var convertedCachedScopes = this.trimAndConvertArrayToLowerCase(__spreadArrays(cachedScopes));\n    var requestScopes = this.trimAndConvertArrayToLowerCase(__spreadArrays(scopes));\n\n    for (var i = 0; i < requestScopes.length; i++) {\n      if (convertedCachedScopes.indexOf(requestScopes[i].toLowerCase()) > -1) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Check if a given scope is present in the request\n   *\n   * @param cachedScopes\n   * @param scopes\n   */\n\n\n  ScopeSet.containsScope = function (cachedScopes, scopes) {\n    var convertedCachedScopes = this.trimAndConvertArrayToLowerCase(__spreadArrays(cachedScopes));\n    var requestScopes = this.trimAndConvertArrayToLowerCase(__spreadArrays(scopes));\n    return requestScopes.every(function (value) {\n      return convertedCachedScopes.indexOf(value.toString().toLowerCase()) >= 0;\n    });\n  };\n  /**\n   *  Trims and converts string to lower case\n   *\n   * @param scopes\n   */\n  // TODO: Rename this, too generic name for a function that only deals with scopes\n\n\n  ScopeSet.trimAndConvertToLowerCase = function (scope) {\n    return scope.trim().toLowerCase();\n  };\n  /**\n   * Performs trimAndConvertToLowerCase on string array\n   * @param scopes\n   */\n\n\n  ScopeSet.trimAndConvertArrayToLowerCase = function (scopes) {\n    var _this = this;\n\n    return scopes.map(function (scope) {\n      return _this.trimAndConvertToLowerCase(scope);\n    });\n  };\n  /**\n   * Trims each scope in scopes array\n   * @param scopes\n   */\n\n\n  ScopeSet.trimScopes = function (scopes) {\n    return scopes.map(function (scope) {\n      return scope.trim();\n    });\n  };\n  /**\n   * Remove one element from a scope array\n   *\n   * @param scopes\n   * @param scope\n   */\n  // TODO: Rename this, too generic name for a function that only deals with scopes\n\n\n  ScopeSet.removeElement = function (scopes, scope) {\n    var scopeVal = this.trimAndConvertToLowerCase(scope);\n    return scopes.filter(function (value) {\n      return value !== scopeVal;\n    });\n  };\n  /**\n   * Parse the scopes into a formatted scopeList\n   * @param scopes\n   */\n\n\n  ScopeSet.parseScope = function (scopes) {\n    var scopeList = \"\";\n\n    if (scopes) {\n      for (var i = 0; i < scopes.length; ++i) {\n        scopeList += i !== scopes.length - 1 ? scopes[i] + \" \" : scopes[i];\n      }\n    }\n\n    return scopeList;\n  };\n  /**\n   * @hidden\n   *\n   * Used to validate the scopes input parameter requested  by the developer.\n   * @param {Array<string>} scopes - Developer requested permissions. Not all scopes are guaranteed to be included in the access token returned.\n   * @param {boolean} scopesRequired - Boolean indicating whether the scopes array is required or not\n   * @ignore\n   */\n\n\n  ScopeSet.validateInputScope = function (scopes, scopesRequired) {\n    if (!scopes) {\n      if (scopesRequired) {\n        throw ClientConfigurationError.createScopesRequiredError(scopes);\n      } else {\n        return;\n      }\n    } // Check that scopes is an array object (also throws error if scopes == null)\n\n\n    if (!Array.isArray(scopes)) {\n      throw ClientConfigurationError.createScopesNonArrayError(scopes);\n    } // Check that scopes is not an empty array\n\n\n    if (scopes.length < 1 && scopesRequired) {\n      throw ClientConfigurationError.createEmptyScopesArrayError(scopes.toString());\n    }\n  };\n  /**\n   * @hidden\n   *\n   * Extracts scope value from the state sent with the authentication request.\n   * @param {string} state\n   * @returns {string} scope.\n   * @ignore\n   */\n\n\n  ScopeSet.getScopeFromState = function (state) {\n    if (state) {\n      var splitIndex = state.indexOf(Constants.resourceDelimiter);\n\n      if (splitIndex > -1 && splitIndex + 1 < state.length) {\n        return state.substring(splitIndex + 1);\n      }\n    }\n\n    return \"\";\n  };\n  /**\n   * @ignore\n   * Appends extraScopesToConsent if passed\n   * @param {@link AuthenticationParameters}\n   */\n\n\n  ScopeSet.appendScopes = function (reqScopes, reqExtraScopesToConsent) {\n    if (reqScopes) {\n      var convertedExtraScopes = reqExtraScopesToConsent ? this.trimAndConvertArrayToLowerCase(__spreadArrays(reqExtraScopesToConsent)) : null;\n      var convertedReqScopes = this.trimAndConvertArrayToLowerCase(__spreadArrays(reqScopes));\n      return convertedExtraScopes ? __spreadArrays(convertedReqScopes, convertedExtraScopes) : convertedReqScopes;\n    }\n\n    return null;\n  }; // #endregion\n\n  /**\n   * @ignore\n   * Returns true if the scopes array only contains openid and/or profile\n   */\n\n\n  ScopeSet.onlyContainsOidcScopes = function (scopes) {\n    var scopesCount = scopes.length;\n    var oidcScopesFound = 0;\n\n    if (scopes.indexOf(Constants.openidScope) > -1) {\n      oidcScopesFound += 1;\n    }\n\n    if (scopes.indexOf(Constants.profileScope) > -1) {\n      oidcScopesFound += 1;\n    }\n\n    return scopesCount > 0 && scopesCount === oidcScopesFound;\n  };\n  /**\n   * @ignore\n   * Returns true if the scopes array only contains openid and/or profile\n   */\n\n\n  ScopeSet.containsAnyOidcScopes = function (scopes) {\n    var containsOpenIdScope = scopes.indexOf(Constants.openidScope) > -1;\n    var containsProfileScope = scopes.indexOf(Constants.profileScope) > -1;\n    return containsOpenIdScope || containsProfileScope;\n  };\n  /**\n   * @ignore\n   * Returns true if the clientId is the only scope in the array\n   */\n\n\n  ScopeSet.onlyContainsClientId = function (scopes, clientId) {\n    // Double negation to force false value returned in case scopes is null\n    return !!scopes && scopes.indexOf(clientId) > -1 && scopes.length === 1;\n  };\n  /**\n   * @ignore\n   * Adds missing OIDC scopes to scopes array without duplication. Since STS requires OIDC scopes for\n   * all implicit flow requests, 'openid' and 'profile' should always be included in the final request\n   */\n\n\n  ScopeSet.appendDefaultScopes = function (scopes) {\n    var extendedScopes = scopes;\n\n    if (extendedScopes.indexOf(Constants.openidScope) === -1) {\n      extendedScopes.push(Constants.openidScope);\n    }\n\n    if (extendedScopes.indexOf(Constants.profileScope) === -1) {\n      extendedScopes.push(Constants.profileScope);\n    }\n\n    return extendedScopes;\n  };\n  /**\n   * @ignore\n   * Removes present OIDC scopes from scopes array.\n   */\n\n\n  ScopeSet.removeDefaultScopes = function (scopes) {\n    return scopes.filter(function (scope) {\n      return scope !== Constants.openidScope && scope !== Constants.profileScope;\n    });\n  };\n  /**\n   * @ignore\n   * Removes clientId from scopes array if included as only scope. If it's not the only scope, it is treated as a resource scope.\n   * @param scopes Array<string>: Pre-normalized scopes array\n   * @param clientId string: The application's clientId that is searched for in the scopes array\n   */\n\n\n  ScopeSet.translateClientIdIfSingleScope = function (scopes, clientId) {\n    return this.onlyContainsClientId(scopes, clientId) ? Constants.oidcScopes : scopes;\n  };\n\n  return ScopeSet;\n}();\n\nexport { ScopeSet };","map":null,"metadata":{},"sourceType":"module"}