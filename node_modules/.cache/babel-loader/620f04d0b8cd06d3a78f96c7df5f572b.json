{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { __spreadArrays } from \"tslib\";\nimport { CryptoUtils } from \"./utils/CryptoUtils\";\nimport { SSOTypes, Constants, PromptState, ResponseTypes } from \"./utils/Constants\";\nimport { StringUtils } from \"./utils/StringUtils\";\nimport { ScopeSet } from \"./ScopeSet\";\nimport { version as libraryVersion } from \"./packageMetadata\";\n/**\n * Nonce: OIDC Nonce definition: https://openid.net/specs/openid-connect-core-1_0.html#IDToken\n * State: OAuth Spec: https://tools.ietf.org/html/rfc6749#section-10.12\n * @hidden\n */\n\nvar ServerRequestParameters =\n/** @class */\nfunction () {\n  /**\n   * Constructor\n   * @param authority\n   * @param clientId\n   * @param scope\n   * @param responseType\n   * @param redirectUri\n   * @param state\n   */\n  function ServerRequestParameters(authority, clientId, responseType, redirectUri, scopes, state, correlationId) {\n    this.authorityInstance = authority;\n    this.clientId = clientId;\n    this.nonce = CryptoUtils.createNewGuid(); // set scope to clientId if null\n\n    this.scopes = scopes ? __spreadArrays(scopes) : Constants.oidcScopes;\n    this.scopes = ScopeSet.trimScopes(this.scopes); // set state (already set at top level)\n\n    this.state = state; // set correlationId\n\n    this.correlationId = correlationId; // telemetry information\n\n    this.xClientSku = \"MSAL.JS\";\n    this.xClientVer = libraryVersion;\n    this.responseType = responseType;\n    this.redirectUri = redirectUri;\n  }\n\n  Object.defineProperty(ServerRequestParameters.prototype, \"authority\", {\n    get: function get() {\n      return this.authorityInstance ? this.authorityInstance.CanonicalAuthority : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @hidden\n   * @ignore\n   *\n   * Utility to populate QueryParameters and ExtraQueryParameters to ServerRequestParamerers\n   * @param request\n   * @param serverAuthenticationRequest\n   */\n\n  ServerRequestParameters.prototype.populateQueryParams = function (account, request, adalIdTokenObject, silentCall) {\n    var queryParameters = {};\n\n    if (request) {\n      // add the prompt parameter to serverRequestParameters if passed\n      if (request.prompt) {\n        this.promptValue = request.prompt;\n      } // Add claims challenge to serverRequestParameters if passed\n\n\n      if (request.claimsRequest) {\n        this.claimsValue = request.claimsRequest;\n      } // if the developer provides one of these, give preference to developer choice\n\n\n      if (ServerRequestParameters.isSSOParam(request)) {\n        queryParameters = this.constructUnifiedCacheQueryParameter(request, null);\n      }\n    }\n\n    if (adalIdTokenObject) {\n      queryParameters = this.constructUnifiedCacheQueryParameter(null, adalIdTokenObject);\n    }\n    /*\n     * adds sid/login_hint if not populated\n     * this.logger.verbose(\"Calling addHint parameters\");\n     */\n\n\n    queryParameters = this.addHintParameters(account, queryParameters); // sanity check for developer passed extraQueryParameters\n\n    var eQParams = request ? request.extraQueryParameters : null; // Populate the extraQueryParameters to be sent to the server\n\n    this.queryParameters = ServerRequestParameters.generateQueryParametersString(queryParameters);\n    this.extraQueryParameters = ServerRequestParameters.generateQueryParametersString(eQParams, silentCall);\n  }; // #region QueryParam helpers\n\n  /**\n   * Constructs extraQueryParameters to be sent to the server for the AuthenticationParameters set by the developer\n   * in any login() or acquireToken() calls\n   * @param idTokenObject\n   * @param extraQueryParameters\n   * @param sid\n   * @param loginHint\n   */\n  // TODO: check how this behaves when domain_hint only is sent in extraparameters and idToken has no upn.\n\n\n  ServerRequestParameters.prototype.constructUnifiedCacheQueryParameter = function (request, idTokenObject) {\n    // preference order: account > sid > login_hint\n    var ssoType;\n    var ssoData;\n    var serverReqParam = {}; // if account info is passed, account.sid > account.login_hint\n\n    if (request) {\n      if (request.account) {\n        var account = request.account;\n\n        if (account.sid) {\n          ssoType = SSOTypes.SID;\n          ssoData = account.sid;\n        } else if (account.userName) {\n          ssoType = SSOTypes.LOGIN_HINT;\n          ssoData = account.userName;\n        }\n      } // sid from request\n      else if (request.sid) {\n          ssoType = SSOTypes.SID;\n          ssoData = request.sid;\n        } // loginHint from request\n        else if (request.loginHint) {\n            ssoType = SSOTypes.LOGIN_HINT;\n            ssoData = request.loginHint;\n          }\n    } // adalIdToken retrieved from cache\n    else if (idTokenObject) {\n        if (idTokenObject.hasOwnProperty(Constants.upn)) {\n          ssoType = SSOTypes.ID_TOKEN;\n          ssoData = idTokenObject[\"upn\"];\n        }\n      }\n\n    serverReqParam = this.addSSOParameter(ssoType, ssoData);\n    return serverReqParam;\n  };\n  /**\n   * @hidden\n   *\n   * Adds login_hint to authorization URL which is used to pre-fill the username field of sign in page for the user if known ahead of time\n   * domain_hint if added skips the email based discovery process of the user - only supported for interactive calls in implicit_flow\n   * domain_req utid received as part of the clientInfo\n   * login_req uid received as part of clientInfo\n   * Also does a sanity check for extraQueryParameters passed by the user to ensure no repeat queryParameters\n   *\n   * @param {@link Account} account - Account for which the token is requested\n   * @param queryparams\n   * @param {@link ServerRequestParameters}\n   * @ignore\n   */\n\n\n  ServerRequestParameters.prototype.addHintParameters = function (account, params) {\n    /*\n     * This is a final check for all queryParams added so far; preference order: sid > login_hint\n     * sid cannot be passed along with login_hint or domain_hint, hence we check both are not populated yet in queryParameters\n     */\n    var qParams = params;\n\n    if (account && !qParams[SSOTypes.SID]) {\n      // sid - populate only if login_hint is not already populated and the account has sid\n      var populateSID = !qParams[SSOTypes.LOGIN_HINT] && account.sid && this.promptValue === PromptState.NONE;\n\n      if (populateSID) {\n        qParams = this.addSSOParameter(SSOTypes.SID, account.sid, qParams);\n      } // login_hint - account.userName\n      else {\n          var populateLoginHint = !qParams[SSOTypes.LOGIN_HINT] && account.userName && !StringUtils.isEmpty(account.userName);\n\n          if (populateLoginHint) {\n            qParams = this.addSSOParameter(SSOTypes.LOGIN_HINT, account.userName, qParams);\n          }\n        }\n    }\n\n    return qParams;\n  };\n  /**\n   * Add SID to extraQueryParameters\n   * @param sid\n   */\n\n\n  ServerRequestParameters.prototype.addSSOParameter = function (ssoType, ssoData, params) {\n    var ssoParam = params || {};\n\n    if (!ssoData) {\n      return ssoParam;\n    }\n\n    switch (ssoType) {\n      case SSOTypes.SID:\n        {\n          ssoParam[SSOTypes.SID] = ssoData;\n          break;\n        }\n\n      case SSOTypes.ID_TOKEN:\n        {\n          ssoParam[SSOTypes.LOGIN_HINT] = ssoData;\n          break;\n        }\n\n      case SSOTypes.LOGIN_HINT:\n        {\n          ssoParam[SSOTypes.LOGIN_HINT] = ssoData;\n          break;\n        }\n    }\n\n    return ssoParam;\n  };\n  /**\n   * Utility to generate a QueryParameterString from a Key-Value mapping of extraQueryParameters passed\n   * @param extraQueryParameters\n   */\n\n\n  ServerRequestParameters.generateQueryParametersString = function (queryParameters, silentCall) {\n    var paramsString = null;\n\n    if (queryParameters) {\n      Object.keys(queryParameters).forEach(function (key) {\n        // sid cannot be passed along with login_hint or domain_hint\n        if (key === Constants.domain_hint && (silentCall || queryParameters[SSOTypes.SID])) {\n          return;\n        }\n\n        if (!paramsString) {\n          paramsString = key + \"=\" + encodeURIComponent(queryParameters[key]);\n        } else {\n          paramsString += \"&\" + key + \"=\" + encodeURIComponent(queryParameters[key]);\n        }\n      });\n    }\n\n    return paramsString;\n  }; // #endregion\n\n  /**\n   * Check to see if there are SSO params set in the Request\n   * @param request\n   */\n\n\n  ServerRequestParameters.isSSOParam = function (request) {\n    return !!(request && (request.account || request.sid || request.loginHint));\n  };\n  /**\n   * Returns the correct response_type string attribute for an acquireToken request configuration\n   * @param accountsMatch boolean: Determines whether the account in the request matches the cached account\n   * @param scopes Array<string>: AuthenticationRequest scopes configuration\n   * @param loginScopesOnly boolean: True if the scopes array ONLY contains the clientId or any combination of OIDC scopes, without resource scopes\n   */\n\n\n  ServerRequestParameters.determineResponseType = function (accountsMatch, scopes) {\n    // Supports getting an id_token by sending in clientId as only scope or OIDC scopes as only scopes\n    if (ScopeSet.onlyContainsOidcScopes(scopes)) {\n      return ResponseTypes.id_token;\n    } // If accounts match, check if OIDC scopes are included, otherwise return id_token_token\n\n\n    return accountsMatch ? this.responseTypeForMatchingAccounts(scopes) : ResponseTypes.id_token_token;\n  };\n  /**\n   * Returns the correct response_type string attribute for an acquireToken request configuration that contains an\n   * account that matches the account in the MSAL cache.\n   * @param scopes Array<string>: AuthenticationRequest scopes configuration\n   */\n\n\n  ServerRequestParameters.responseTypeForMatchingAccounts = function (scopes) {\n    // Opt-into also requesting an ID token by sending in 'openid', 'profile' or both along with resource scopes when login is not necessary.\n    return ScopeSet.containsAnyOidcScopes(scopes) ? ResponseTypes.id_token_token : ResponseTypes.token;\n  };\n\n  return ServerRequestParameters;\n}();\n\nexport { ServerRequestParameters };","map":null,"metadata":{},"sourceType":"module"}