{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { __assign, __spreadArrays } from \"tslib\";\nimport DefaultEvent from \"./DefaultEvent\";\nimport { Constants } from \"../utils/Constants\";\nimport ApiEvent from \"./ApiEvent\";\nimport HttpEvent from \"./HttpEvent\";\nimport { version as libraryVersion } from \"../packageMetadata\";\n\nvar TelemetryManager =\n/** @class */\nfunction () {\n  function TelemetryManager(config, telemetryEmitter, logger) {\n    // correlation Id to list of events\n    this.completedEvents = {}; // event key to event\n\n    this.inProgressEvents = {}; // correlation id to map of eventname to count\n\n    this.eventCountByCorrelationId = {}; // Implement after API EVENT\n\n    this.onlySendFailureTelemetry = false; // TODO THROW if bad options\n\n    this.telemetryPlatform = __assign({\n      sdk: Constants.libraryName,\n      sdkVersion: libraryVersion,\n      networkInformation: {\n        // @ts-ignore\n        connectionSpeed: typeof navigator !== \"undefined\" && navigator.connection && navigator.connection.effectiveType\n      }\n    }, config.platform);\n    this.clientId = config.clientId;\n    this.onlySendFailureTelemetry = config.onlySendFailureTelemetry;\n    /*\n     * TODO, when i get to wiring this through, think about what it means if\n     * a developer does not implement telem at all, we still instrument, but telemetryEmitter can be\n     * optional?\n     */\n\n    this.telemetryEmitter = telemetryEmitter;\n    this.logger = logger;\n  }\n\n  TelemetryManager.getTelemetrymanagerStub = function (clientId, logger) {\n    var applicationName = \"UnSetStub\";\n    var applicationVersion = \"0.0\";\n\n    var telemetryEmitter = function telemetryEmitter() {};\n\n    var telemetryPlatform = {\n      applicationName: applicationName,\n      applicationVersion: applicationVersion\n    };\n    var telemetryManagerConfig = {\n      platform: telemetryPlatform,\n      clientId: clientId\n    };\n    return new this(telemetryManagerConfig, telemetryEmitter, logger);\n  };\n\n  TelemetryManager.prototype.startEvent = function (event) {\n    this.logger.verbose(\"Telemetry Event started: \" + event.key);\n\n    if (!this.telemetryEmitter) {\n      return;\n    }\n\n    event.start();\n    this.inProgressEvents[event.key] = event;\n  };\n\n  TelemetryManager.prototype.stopEvent = function (event) {\n    this.logger.verbose(\"Telemetry Event stopped: \" + event.key);\n\n    if (!this.telemetryEmitter || !this.inProgressEvents[event.key]) {\n      return;\n    }\n\n    event.stop();\n    this.incrementEventCount(event);\n    var completedEvents = this.completedEvents[event.telemetryCorrelationId];\n    this.completedEvents[event.telemetryCorrelationId] = __spreadArrays(completedEvents || [], [event]);\n    delete this.inProgressEvents[event.key];\n  };\n\n  TelemetryManager.prototype.flush = function (correlationId) {\n    var _this = this;\n\n    this.logger.verbose(\"Flushing telemetry events: \" + correlationId); // If there is only unfinished events should this still return them?\n\n    if (!this.telemetryEmitter || !this.completedEvents[correlationId]) {\n      return;\n    }\n\n    var orphanedEvents = this.getOrphanedEvents(correlationId);\n    orphanedEvents.forEach(function (event) {\n      return _this.incrementEventCount(event);\n    });\n\n    var eventsToFlush = __spreadArrays(this.completedEvents[correlationId], orphanedEvents);\n\n    delete this.completedEvents[correlationId];\n    var eventCountsToFlush = this.eventCountByCorrelationId[correlationId];\n    delete this.eventCountByCorrelationId[correlationId]; // TODO add funcitonality for onlyFlushFailures after implementing api event? ??\n\n    if (!eventsToFlush || !eventsToFlush.length) {\n      return;\n    }\n\n    var defaultEvent = new DefaultEvent(this.telemetryPlatform, correlationId, this.clientId, eventCountsToFlush);\n\n    var eventsWithDefaultEvent = __spreadArrays(eventsToFlush, [defaultEvent]);\n\n    this.telemetryEmitter(eventsWithDefaultEvent.map(function (e) {\n      return e.get();\n    }));\n  };\n\n  TelemetryManager.prototype.createAndStartApiEvent = function (correlationId, apiEventIdentifier) {\n    var apiEvent = new ApiEvent(correlationId, this.logger.isPiiLoggingEnabled(), apiEventIdentifier);\n    this.startEvent(apiEvent);\n    return apiEvent;\n  };\n\n  TelemetryManager.prototype.stopAndFlushApiEvent = function (correlationId, apiEvent, wasSuccessful, errorCode) {\n    apiEvent.wasSuccessful = wasSuccessful;\n\n    if (errorCode) {\n      apiEvent.apiErrorCode = errorCode;\n    }\n\n    this.stopEvent(apiEvent);\n    this.flush(correlationId);\n  };\n\n  TelemetryManager.prototype.createAndStartHttpEvent = function (correlation, httpMethod, url, eventLabel) {\n    var httpEvent = new HttpEvent(correlation, eventLabel);\n    httpEvent.url = url;\n    httpEvent.httpMethod = httpMethod;\n    this.startEvent(httpEvent);\n    return httpEvent;\n  };\n\n  TelemetryManager.prototype.incrementEventCount = function (event) {\n    var _a;\n    /*\n     * TODO, name cache event different?\n     * if type is cache event, change name\n     */\n\n\n    var eventName = event.eventName;\n    var eventCount = this.eventCountByCorrelationId[event.telemetryCorrelationId];\n\n    if (!eventCount) {\n      this.eventCountByCorrelationId[event.telemetryCorrelationId] = (_a = {}, _a[eventName] = 1, _a);\n    } else {\n      eventCount[eventName] = eventCount[eventName] ? eventCount[eventName] + 1 : 1;\n    }\n  };\n\n  TelemetryManager.prototype.getOrphanedEvents = function (correlationId) {\n    var _this = this;\n\n    return Object.keys(this.inProgressEvents).reduce(function (memo, eventKey) {\n      if (eventKey.indexOf(correlationId) !== -1) {\n        var event_1 = _this.inProgressEvents[eventKey];\n        delete _this.inProgressEvents[eventKey];\n        return __spreadArrays(memo, [event_1]);\n      }\n\n      return memo;\n    }, []);\n  };\n\n  return TelemetryManager;\n}();\n\nexport default TelemetryManager;","map":null,"metadata":{},"sourceType":"module"}