{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { __extends, __spreadArrays } from \"tslib\";\nimport { Constants, PersistentCacheKeys, TemporaryCacheKeys, ErrorCacheKeys, ServerHashParamKeys, SESSION_STORAGE } from \"../utils/Constants\";\nimport { AccessTokenCacheItem } from \"./AccessTokenCacheItem\";\nimport { BrowserStorage } from \"./BrowserStorage\";\nimport { RequestUtils } from \"../utils/RequestUtils\";\nimport { StringUtils } from \"../utils/StringUtils\";\nimport { IdToken } from \"../IdToken\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\n/**\n * @hidden\n */\n\nvar AuthCache =\n/** @class */\nfunction (_super) {\n  __extends(AuthCache, _super);\n\n  function AuthCache(clientId, cacheLocation, storeAuthStateInCookie) {\n    var _this = _super.call(this, cacheLocation) || this;\n\n    _this.temporaryCache = new BrowserStorage(SESSION_STORAGE);\n    _this.clientId = clientId; // This is hardcoded to true for now. We may make this configurable in the future\n\n    _this.rollbackEnabled = true;\n\n    _this.migrateCacheEntries(storeAuthStateInCookie);\n\n    return _this;\n  }\n  /**\n   * Support roll back to old cache schema until the next major release: true by default now\n   * @param storeAuthStateInCookie\n   */\n\n\n  AuthCache.prototype.migrateCacheEntries = function (storeAuthStateInCookie) {\n    var _this = this;\n\n    var idTokenKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.IDTOKEN;\n    var clientInfoKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.CLIENT_INFO;\n    var errorKey = Constants.cachePrefix + \".\" + ErrorCacheKeys.ERROR;\n    var errorDescKey = Constants.cachePrefix + \".\" + ErrorCacheKeys.ERROR_DESC;\n\n    var idTokenValue = _super.prototype.getItem.call(this, idTokenKey);\n\n    var idToken;\n\n    if (idTokenValue) {\n      try {\n        idToken = new IdToken(idTokenValue);\n      } catch (e) {\n        return;\n      }\n    }\n\n    if (idToken && idToken.claims && idToken.claims.aud === this.clientId) {\n      var clientInfoValue = _super.prototype.getItem.call(this, clientInfoKey);\n\n      var errorValue = _super.prototype.getItem.call(this, errorKey);\n\n      var errorDescValue = _super.prototype.getItem.call(this, errorDescKey);\n\n      var values_1 = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n      var keysToMigrate = [PersistentCacheKeys.IDTOKEN, PersistentCacheKeys.CLIENT_INFO, ErrorCacheKeys.ERROR, ErrorCacheKeys.ERROR_DESC];\n      keysToMigrate.forEach(function (cacheKey, index) {\n        return _this.duplicateCacheEntry(cacheKey, values_1[index], storeAuthStateInCookie);\n      });\n    }\n  };\n  /**\n   * Utility function to help with roll back keys\n   * @param newKey\n   * @param value\n   * @param storeAuthStateInCookie\n   */\n\n\n  AuthCache.prototype.duplicateCacheEntry = function (newKey, value, storeAuthStateInCookie) {\n    if (value) {\n      this.setItem(newKey, value, storeAuthStateInCookie);\n    }\n  };\n  /**\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n   * @param key\n   * @param addInstanceId\n   */\n\n\n  AuthCache.prototype.generateCacheKey = function (key, addInstanceId) {\n    try {\n      // Defined schemas do not need the key appended\n      JSON.parse(key);\n      return key;\n    } catch (e) {\n      if (key.indexOf(\"\" + Constants.cachePrefix) === 0 || key.indexOf(Constants.adalIdToken) === 0) {\n        return key;\n      }\n\n      return addInstanceId ? Constants.cachePrefix + \".\" + this.clientId + \".\" + key : Constants.cachePrefix + \".\" + key;\n    }\n  };\n  /**\n   * Validates that the input cache key contains the account search terms (clientId and homeAccountIdentifier) and\n   * then whether or not it contains the \"scopes\", depending on the token type being searched for. With matching account\n   * search terms, Access Token search tries to match the \"scopes\" keyword, while Id Token search expects \"scopes\" to not be included.\n   * @param key\n   * @param clientId\n   * @param homeAccountIdentifier\n   * @param tokenType\n   */\n\n\n  AuthCache.prototype.matchKeyForType = function (key, clientId, homeAccountIdentifier, tokenType) {\n    // All valid token cache item keys are valid JSON objects, ignore keys that aren't\n    var parsedKey = StringUtils.validateAndParseJsonCacheKey(key);\n\n    if (!parsedKey) {\n      return null;\n    } // Does the cache item match the request account\n\n\n    var accountMatches = key.match(clientId) && key.match(homeAccountIdentifier); // Does the cache item match the requested token type\n\n    var tokenTypeMatches = false;\n\n    switch (tokenType) {\n      case ServerHashParamKeys.ACCESS_TOKEN:\n        // Cache item is an access token if scopes are included in the cache item key\n        tokenTypeMatches = !!key.match(Constants.scopes);\n        break;\n\n      case ServerHashParamKeys.ID_TOKEN:\n        // Cache may be an ID token if scopes are NOT included in the cache item key\n        tokenTypeMatches = !key.match(Constants.scopes);\n        break;\n    }\n\n    return accountMatches && tokenTypeMatches ? parsedKey : null;\n  };\n  /**\n   * add value to storage\n   * @param key\n   * @param value\n   * @param enableCookieStorage\n   */\n\n\n  AuthCache.prototype.setItem = function (key, value, enableCookieStorage) {\n    _super.prototype.setItem.call(this, this.generateCacheKey(key, true), value, enableCookieStorage); // Values stored in cookies will have rollback disabled to minimize cookie length\n\n\n    if (this.rollbackEnabled && !enableCookieStorage) {\n      _super.prototype.setItem.call(this, this.generateCacheKey(key, false), value, enableCookieStorage);\n    }\n  };\n  /**\n   * get one item by key from storage\n   * @param key\n   * @param enableCookieStorage\n   */\n\n\n  AuthCache.prototype.getItem = function (key, enableCookieStorage) {\n    return _super.prototype.getItem.call(this, this.generateCacheKey(key, true), enableCookieStorage);\n  };\n  /**\n   * remove value from storage\n   * @param key\n   */\n\n\n  AuthCache.prototype.removeItem = function (key) {\n    this.temporaryCache.removeItem(this.generateCacheKey(key, true));\n\n    _super.prototype.removeItem.call(this, this.generateCacheKey(key, true));\n\n    if (this.rollbackEnabled) {\n      _super.prototype.removeItem.call(this, this.generateCacheKey(key, false));\n    }\n  };\n  /**\n   * Sets temporary cache value\n   * @param key\n   * @param value\n   * @param enableCookieStorage\n   */\n\n\n  AuthCache.prototype.setTemporaryItem = function (key, value, enableCookieStorage) {\n    this.temporaryCache.setItem(this.generateCacheKey(key, true), value, enableCookieStorage);\n  };\n  /**\n   * Gets temporary cache value\n   * @param key\n   * @param enableCookieStorage\n   */\n\n\n  AuthCache.prototype.getTemporaryItem = function (key, enableCookieStorage) {\n    return this.temporaryCache.getItem(this.generateCacheKey(key, true), enableCookieStorage);\n  };\n  /**\n   * Reset the cache items\n   */\n\n\n  AuthCache.prototype.resetCacheItems = function () {\n    var storage = window[this.cacheLocation];\n    var key;\n\n    for (key in storage) {\n      // Check if key contains msal prefix; For now, we are clearing all cache items created by MSAL.js\n      if (storage.hasOwnProperty(key) && key.indexOf(Constants.cachePrefix) !== -1) {\n        _super.prototype.removeItem.call(this, key); // TODO: Clear cache based on client id (clarify use cases where this is needed)\n\n      }\n    }\n  };\n  /**\n   * Reset all temporary cache items\n   */\n\n\n  AuthCache.prototype.resetTempCacheItems = function (state) {\n    var _this = this;\n\n    var stateId = state && RequestUtils.parseLibraryState(state).id;\n    var isTokenRenewalInProgress = this.tokenRenewalInProgress(state);\n    var storage = window[this.cacheLocation]; // check state and remove associated cache\n\n    if (stateId && !isTokenRenewalInProgress) {\n      Object.keys(storage).forEach(function (key) {\n        if (key.indexOf(stateId) !== -1) {\n          _this.removeItem(key);\n\n          _super.prototype.clearItemCookie.call(_this, key);\n        }\n      });\n    } // delete the interaction status cache\n\n\n    this.setInteractionInProgress(false);\n    this.removeItem(TemporaryCacheKeys.REDIRECT_REQUEST);\n  };\n  /**\n   * Set cookies for IE\n   * @param cName\n   * @param cValue\n   * @param expires\n   */\n\n\n  AuthCache.prototype.setItemCookie = function (cName, cValue, expires) {\n    _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, true), cValue, expires);\n\n    if (this.rollbackEnabled) {\n      _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, false), cValue, expires);\n    }\n  };\n\n  AuthCache.prototype.clearItemCookie = function (cName) {\n    _super.prototype.clearItemCookie.call(this, this.generateCacheKey(cName, true));\n\n    if (this.rollbackEnabled) {\n      _super.prototype.clearItemCookie.call(this, this.generateCacheKey(cName, false));\n    }\n  };\n  /**\n   * get one item by key from cookies\n   * @param cName\n   */\n\n\n  AuthCache.prototype.getItemCookie = function (cName) {\n    return _super.prototype.getItemCookie.call(this, this.generateCacheKey(cName, true));\n  };\n  /**\n   * Get all tokens of a certain type from the cache\n   * @param clientId\n   * @param homeAccountIdentifier\n   * @param tokenType\n   */\n\n\n  AuthCache.prototype.getAllTokensByType = function (clientId, homeAccountIdentifier, tokenType) {\n    var _this = this;\n\n    var results = Object.keys(window[this.cacheLocation]).reduce(function (tokens, key) {\n      var matchedTokenKey = _this.matchKeyForType(key, clientId, homeAccountIdentifier, tokenType);\n\n      if (matchedTokenKey) {\n        var value = _this.getItem(key);\n\n        if (value) {\n          try {\n            var newAccessTokenCacheItem = new AccessTokenCacheItem(matchedTokenKey, JSON.parse(value));\n            return tokens.concat([newAccessTokenCacheItem]);\n          } catch (err) {\n            // Skip cache items with non-valid JSON values\n            return tokens;\n          }\n        }\n      }\n\n      return tokens;\n    }, []);\n    return results;\n  };\n  /**\n   * Get all access tokens in the cache\n   * @param clientId\n   * @param homeAccountIdentifier\n   */\n\n\n  AuthCache.prototype.getAllAccessTokens = function (clientId, homeAccountIdentifier) {\n    return this.getAllTokensByType(clientId, homeAccountIdentifier, ServerHashParamKeys.ACCESS_TOKEN);\n  };\n  /**\n   * Get all id tokens in the cache in the form of AccessTokenCacheItem objects so they are\n   * in a normalized format and can make use of the existing cached access token validation logic\n   */\n\n\n  AuthCache.prototype.getAllIdTokens = function (clientId, homeAccountIdentifier) {\n    return this.getAllTokensByType(clientId, homeAccountIdentifier, ServerHashParamKeys.ID_TOKEN);\n  };\n  /**\n   * Get all access and ID tokens in the cache\n   * @param clientId\n   * @param homeAccountIdentifier\n   */\n\n\n  AuthCache.prototype.getAllTokens = function (clientId, homeAccountIdentifier) {\n    var accessTokens = this.getAllAccessTokens(clientId, homeAccountIdentifier);\n    var idTokens = this.getAllIdTokens(clientId, homeAccountIdentifier);\n    return __spreadArrays(accessTokens, idTokens);\n  };\n  /**\n   * Returns whether or not interaction is currently in progress. Optionally scope it to just this clientId\n   * @param forThisClient\n   */\n\n\n  AuthCache.prototype.isInteractionInProgress = function (matchClientId) {\n    var clientId = this.getInteractionInProgress();\n\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  };\n  /**\n   * Returns the clientId of the interaction currently in progress\n   */\n\n\n  AuthCache.prototype.getInteractionInProgress = function () {\n    return this.getTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.INTERACTION_STATUS, false));\n  };\n  /**\n   * Sets interaction in progress state\n   * @param isInProgress\n   */\n\n\n  AuthCache.prototype.setInteractionInProgress = function (newInProgressValue) {\n    if (newInProgressValue) {\n      if (this.isInteractionInProgress(false)) {\n        throw ClientAuthError.createAcquireTokenInProgressError();\n      } else {\n        // Ensure we don't overwrite interaction in progress for a different clientId\n        this.setTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.INTERACTION_STATUS, false), this.clientId);\n      }\n    } else if (!newInProgressValue && this.isInteractionInProgress(true)) {\n      // Only remove if the current in progress interaction is for this clientId\n      this.removeItem(this.generateCacheKey(TemporaryCacheKeys.INTERACTION_STATUS, false));\n    }\n  };\n  /**\n   * Return if the token renewal is still in progress\n   *\n   * @param stateValue\n   */\n\n\n  AuthCache.prototype.tokenRenewalInProgress = function (stateValue) {\n    var renewStatus = this.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, stateValue));\n    return !!(renewStatus && renewStatus === Constants.inProgress);\n  };\n  /**\n   * Clear all cookies\n   */\n\n\n  AuthCache.prototype.clearMsalCookie = function (state) {\n    var _this = this;\n    /*\n     * If state is truthy, remove values associated with that request.\n     * Otherwise, remove all MSAL cookies.\n     */\n\n\n    if (state) {\n      this.clearItemCookie(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN, state));\n      this.clearItemCookie(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, state));\n      this.clearItemCookie(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.LOGIN_REQUEST, state));\n      this.clearItemCookie(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_ACQ_TOKEN, state));\n    } else {\n      var cookies = document.cookie.split(\";\");\n      cookies.forEach(function (cookieString) {\n        var cookieName = cookieString.trim().split(\"=\")[0];\n\n        if (cookieName.indexOf(Constants.cachePrefix) > -1) {\n          _super.prototype.clearItemCookie.call(_this, cookieName);\n        }\n      });\n    }\n  };\n  /**\n   * Create acquireTokenAccountKey to cache account object\n   * @param accountId\n   * @param state\n   */\n\n\n  AuthCache.generateAcquireTokenAccountKey = function (accountId, state) {\n    var stateId = RequestUtils.parseLibraryState(state).id;\n    return \"\" + TemporaryCacheKeys.ACQUIRE_TOKEN_ACCOUNT + Constants.resourceDelimiter + accountId + Constants.resourceDelimiter + stateId;\n  };\n  /**\n   * Create authorityKey to cache authority\n   * @param state\n   */\n\n\n  AuthCache.generateAuthorityKey = function (state) {\n    return AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.AUTHORITY, state);\n  };\n  /**\n   * Generates the cache key for temporary cache items, using request state\n   * @param tempCacheKey Cache key prefix\n   * @param state Request state value\n   */\n\n\n  AuthCache.generateTemporaryCacheKey = function (tempCacheKey, state) {\n    // Use the state id (a guid), in the interest of shorter key names, which is important for cookies.\n    var stateId = RequestUtils.parseLibraryState(state).id;\n    return \"\" + tempCacheKey + Constants.resourceDelimiter + stateId;\n  };\n\n  return AuthCache;\n}(BrowserStorage);\n\nexport { AuthCache };","map":null,"metadata":{},"sourceType":"module"}