{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { UrlUtils } from \"./UrlUtils\";\nimport { TemporaryCacheKeys, Constants } from \"./Constants\";\nimport { TimeUtils } from \"./TimeUtils\";\n\nvar WindowUtils =\n/** @class */\nfunction () {\n  function WindowUtils() {}\n  /**\n   * @hidden\n   * Checks if the current page is running in an iframe.\n   * @ignore\n   */\n\n\n  WindowUtils.isInIframe = function () {\n    return window.parent !== window;\n  };\n  /**\n   * @hidden\n   * Check if the current page is running in a popup.\n   * @ignore\n   */\n\n\n  WindowUtils.isInPopup = function () {\n    return !!(window.opener && window.opener !== window);\n  };\n  /**\n   * @hidden\n   * @param prefix\n   * @param scopes\n   * @param authority\n   */\n\n\n  WindowUtils.generateFrameName = function (prefix, requestSignature) {\n    return \"\" + prefix + Constants.resourceDelimiter + requestSignature;\n  };\n  /**\n   * @hidden\n   * Polls an iframe until it loads a url with a hash\n   * @ignore\n   */\n\n\n  WindowUtils.monitorIframeForHash = function (contentWindow, timeout, urlNavigate, logger) {\n    return new Promise(function (resolve, reject) {\n      /*\n       * Polling for iframes can be purely timing based,\n       * since we don't need to account for interaction.\n       */\n      var nowMark = TimeUtils.relativeNowMs();\n      var timeoutMark = nowMark + timeout;\n      logger.verbose(\"monitorWindowForIframe polling started\");\n      var intervalId = setInterval(function () {\n        if (TimeUtils.relativeNowMs() > timeoutMark) {\n          logger.error(\"monitorIframeForHash unable to find hash in url, timing out\");\n          logger.errorPii(\"monitorIframeForHash polling timed out for url: \" + urlNavigate);\n          clearInterval(intervalId);\n          reject(ClientAuthError.createTokenRenewalTimeoutError());\n          return;\n        }\n\n        var href;\n\n        try {\n          /*\n           * Will throw if cross origin,\n           * which should be caught and ignored\n           * since we need the interval to keep running while on STS UI.\n           */\n          href = contentWindow.location.href;\n        } catch (e) {}\n\n        if (href && UrlUtils.urlContainsHash(href)) {\n          logger.verbose(\"monitorIframeForHash found url in hash\");\n          clearInterval(intervalId);\n          resolve(contentWindow.location.hash);\n        }\n      }, WindowUtils.POLLING_INTERVAL_MS);\n    });\n  };\n  /**\n   * @hidden\n   * Polls a popup until it loads a url with a hash\n   * @ignore\n   */\n\n\n  WindowUtils.monitorPopupForHash = function (contentWindow, timeout, urlNavigate, logger) {\n    return new Promise(function (resolve, reject) {\n      /*\n       * Polling for popups needs to be tick-based,\n       * since a non-trivial amount of time can be spent on interaction (which should not count against the timeout).\n       */\n      var maxTicks = timeout / WindowUtils.POLLING_INTERVAL_MS;\n      var ticks = 0;\n      logger.verbose(\"monitorWindowForHash polling started\");\n      var intervalId = setInterval(function () {\n        if (contentWindow.closed) {\n          logger.error(\"monitorWindowForHash window closed\");\n          clearInterval(intervalId);\n          reject(ClientAuthError.createUserCancelledError());\n          return;\n        }\n\n        var href;\n\n        try {\n          /*\n           * Will throw if cross origin,\n           * which should be caught and ignored\n           * since we need the interval to keep running while on STS UI.\n           */\n          href = contentWindow.location.href;\n        } catch (e) {} // Don't process blank pages or cross domain\n\n\n        if (!href || href === \"about:blank\") {\n          return;\n        }\n        /*\n         * Only run clock when we are on same domain for popups\n         * as popup operations can take a long time.\n         */\n\n\n        ticks++;\n\n        if (href && UrlUtils.urlContainsHash(href)) {\n          logger.verbose(\"monitorPopupForHash found url in hash\");\n          clearInterval(intervalId);\n          var hash = contentWindow.location.hash;\n          WindowUtils.clearUrlFragment(contentWindow);\n          resolve(hash);\n        } else if (ticks > maxTicks) {\n          logger.error(\"monitorPopupForHash unable to find hash in url, timing out\");\n          logger.errorPii(\"monitorPopupForHash polling timed out for url: \" + urlNavigate);\n          clearInterval(intervalId);\n          reject(ClientAuthError.createTokenRenewalTimeoutError());\n        }\n      }, WindowUtils.POLLING_INTERVAL_MS);\n    });\n  };\n  /**\n   * @hidden\n   * Loads iframe with authorization endpoint URL\n   * @ignore\n   */\n\n\n  WindowUtils.loadFrame = function (urlNavigate, frameName, timeoutMs, logger) {\n    var _this = this;\n    /*\n     * This trick overcomes iframe navigation in IE\n     * IE does not load the page consistently in iframe\n     */\n\n\n    logger.infoPii(\"LoadFrame: \" + frameName);\n    return new Promise(function (resolve, reject) {\n      setTimeout(function () {\n        var frameHandle = _this.loadFrameSync(urlNavigate, frameName, logger);\n\n        if (!frameHandle) {\n          reject(\"Unable to load iframe with name: \" + frameName);\n          return;\n        }\n\n        resolve(frameHandle);\n      }, timeoutMs);\n    });\n  };\n  /**\n   * @hidden\n   * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\n   * @param urlNavigate\n   * @param frameName\n   * @param logger\n   */\n\n\n  WindowUtils.loadFrameSync = function (urlNavigate, frameName, logger) {\n    var frameHandle = WindowUtils.addHiddenIFrame(frameName, logger); // returning to handle null in loadFrame, also to avoid null object access errors\n\n    if (!frameHandle) {\n      return null;\n    } else if (frameHandle.src === \"\" || frameHandle.src === \"about:blank\") {\n      frameHandle.src = urlNavigate;\n      logger.infoPii(\"Frame Name : \" + frameName + \" Navigated to: \" + urlNavigate);\n    }\n\n    return frameHandle;\n  };\n  /**\n   * @hidden\n   * Adds the hidden iframe for silent token renewal.\n   * @ignore\n   */\n\n\n  WindowUtils.addHiddenIFrame = function (iframeId, logger) {\n    if (typeof iframeId === \"undefined\") {\n      return null;\n    }\n\n    logger.info(\"Add msal iframe to document\");\n    logger.infoPii(\"Add msal frame to document:\" + iframeId);\n    var adalFrame = document.getElementById(iframeId);\n\n    if (!adalFrame) {\n      logger.verbose(\"Add msal iframe does not exist\");\n      var ifr = document.createElement(\"iframe\");\n      ifr.setAttribute(\"id\", iframeId);\n      ifr.setAttribute(\"aria-hidden\", \"true\");\n      ifr.style.visibility = \"hidden\";\n      ifr.style.position = \"absolute\";\n      ifr.style.width = ifr.style.height = \"0\";\n      ifr.style.border = \"0\";\n      ifr.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n      adalFrame = document.getElementsByTagName(\"body\")[0].appendChild(ifr);\n    } else {\n      logger.verbose(\"Add msal iframe already exists\");\n    }\n\n    return adalFrame;\n  };\n  /**\n   * @hidden\n   * Removes a hidden iframe from the page.\n   * @ignore\n   */\n\n\n  WindowUtils.removeHiddenIframe = function (iframe) {\n    if (document.body === iframe.parentNode) {\n      document.body.removeChild(iframe);\n    }\n  };\n  /**\n   * @hidden\n   * Find and return the iframe element with the given hash\n   * @ignore\n   */\n\n\n  WindowUtils.getIframeWithHash = function (hash) {\n    var iframes = document.getElementsByTagName(\"iframe\");\n    var iframeArray = Array.apply(null, Array(iframes.length)).map(function (iframe, index) {\n      return iframes.item(index);\n    }); // eslint-disable-line prefer-spread\n\n    return iframeArray.filter(function (iframe) {\n      try {\n        return iframe.contentWindow.location.hash === hash;\n      } catch (e) {\n        return false;\n      }\n    })[0];\n  };\n  /**\n   * @hidden\n   * Returns an array of all the popups opened by MSAL\n   * @ignore\n   */\n\n\n  WindowUtils.getPopups = function () {\n    if (!window.openedWindows) {\n      window.openedWindows = [];\n    }\n\n    return window.openedWindows;\n  };\n  /**\n   * @hidden\n   * Find and return the popup with the given hash\n   * @ignore\n   */\n\n\n  WindowUtils.getPopUpWithHash = function (hash) {\n    return WindowUtils.getPopups().filter(function (popup) {\n      try {\n        return popup.location.hash === hash;\n      } catch (e) {\n        return false;\n      }\n    })[0];\n  };\n  /**\n   * @hidden\n   * Add the popup to the known list of popups\n   * @ignore\n   */\n\n\n  WindowUtils.trackPopup = function (popup) {\n    WindowUtils.getPopups().push(popup);\n  };\n  /**\n   * @hidden\n   * Close all popups\n   * @ignore\n   */\n\n\n  WindowUtils.closePopups = function () {\n    WindowUtils.getPopups().forEach(function (popup) {\n      return popup.close();\n    });\n  };\n  /**\n   * @ignore\n   *\n   * blocks any login/acquireToken calls to reload from within a hidden iframe (generated for silent calls)\n   */\n\n\n  WindowUtils.blockReloadInHiddenIframes = function () {\n    // return an error if called from the hidden iframe created by the msal js silent calls\n    if (UrlUtils.urlContainsHash(window.location.hash) && WindowUtils.isInIframe()) {\n      throw ClientAuthError.createBlockTokenRequestsInHiddenIframeError();\n    }\n  };\n  /**\n   *\n   * @param cacheStorage\n   */\n\n\n  WindowUtils.checkIfBackButtonIsPressed = function (cacheStorage) {\n    var redirectCache = cacheStorage.getItem(TemporaryCacheKeys.REDIRECT_REQUEST); // if redirect request is set and there is no hash\n\n    if (redirectCache && !UrlUtils.urlContainsHash(window.location.hash)) {\n      var splitCache = redirectCache.split(Constants.resourceDelimiter);\n      splitCache.shift();\n      var state = splitCache.length > 0 ? splitCache.join(Constants.resourceDelimiter) : null;\n      cacheStorage.resetTempCacheItems(state);\n    }\n  };\n  /**\n   * Removes url fragment from browser url\n   */\n\n\n  WindowUtils.clearUrlFragment = function (contentWindow) {\n    contentWindow.location.hash = \"\"; // Office.js sets history.replaceState to null\n\n    if (typeof contentWindow.history.replaceState === \"function\") {\n      // Full removes \"#\" from url\n      contentWindow.history.replaceState(null, null, \"\" + contentWindow.location.pathname + contentWindow.location.search);\n    }\n  };\n  /**\n   * @hidden\n   * Interval in milliseconds that we poll a window\n   * @ignore\n   */\n\n\n  WindowUtils.POLLING_INTERVAL_MS = 50;\n  return WindowUtils;\n}();\n\nexport { WindowUtils };","map":null,"metadata":{},"sourceType":"module"}