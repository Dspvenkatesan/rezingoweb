{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { AccessTokenKey } from \"./cache/AccessTokenKey\";\nimport { AccessTokenValue } from \"./cache/AccessTokenValue\";\nimport { ServerRequestParameters } from \"./ServerRequestParameters\";\nimport { AuthorityType } from \"./authority/Authority\";\nimport { ClientInfo } from \"./ClientInfo\";\nimport { IdToken } from \"./IdToken\";\nimport { AuthCache } from \"./cache/AuthCache\";\nimport { Account } from \"./Account\";\nimport { ScopeSet } from \"./ScopeSet\";\nimport { StringUtils } from \"./utils/StringUtils\";\nimport { WindowUtils } from \"./utils/WindowUtils\";\nimport { TokenUtils } from \"./utils/TokenUtils\";\nimport { TimeUtils } from \"./utils/TimeUtils\";\nimport { UrlUtils } from \"./utils/UrlUtils\";\nimport { RequestUtils } from \"./utils/RequestUtils\";\nimport { ResponseUtils } from \"./utils/ResponseUtils\";\nimport { AuthorityFactory } from \"./authority/AuthorityFactory\";\nimport { buildConfiguration } from \"./Configuration\";\nimport { ClientConfigurationError } from \"./error/ClientConfigurationError\";\nimport { AuthError } from \"./error/AuthError\";\nimport { ClientAuthError, ClientAuthErrorMessage } from \"./error/ClientAuthError\";\nimport { ServerError } from \"./error/ServerError\";\nimport { InteractionRequiredAuthError } from \"./error/InteractionRequiredAuthError\";\nimport { buildResponseStateOnly } from \"./AuthResponse\";\nimport TelemetryManager from \"./telemetry/TelemetryManager\";\nimport { API_EVENT_IDENTIFIER } from \"./telemetry/ApiEvent\";\nimport { Constants, ServerHashParamKeys, ResponseTypes, TemporaryCacheKeys, PersistentCacheKeys, ErrorCacheKeys, FramePrefix } from \"./utils/Constants\";\nimport { CryptoUtils } from \"./utils/CryptoUtils\";\nimport { TrustedAuthority } from \"./authority/TrustedAuthority\";\nimport { AuthCacheUtils } from \"./utils/AuthCacheUtils\"; // default authority\n\nvar DEFAULT_AUTHORITY = \"https://login.microsoftonline.com/common\";\n/**\n * UserAgentApplication class\n *\n * Object Instance that the developer can use to make loginXX OR acquireTokenXX functions\n */\n\nvar UserAgentApplication =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * Constructor for the UserAgentApplication used to instantiate the UserAgentApplication object\n   *\n   * Important attributes in the Configuration object for auth are:\n   * - clientID: the application ID of your application.\n   * You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview\n   * - authority: the authority URL for your application.\n   *\n   * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.\n   * It is of the form https://login.microsoftonline.com/&lt;Enter_the_Tenant_Info_Here&gt;.\n   * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\n   * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\n   * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\n   * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\n   *\n   *\n   * In Azure B2C, authority is of the form https://&lt;instance&gt;/tfp/&lt;tenant&gt;/&lt;policyName&gt;/\n   *\n   * @param {@link (Configuration:type)} configuration object for the MSAL UserAgentApplication instance\n   */\n  function UserAgentApplication(configuration) {\n    // callbacks for token/error\n    this.authResponseCallback = null;\n    this.tokenReceivedCallback = null;\n    this.errorReceivedCallback = null; // Set the Configuration\n\n    this.config = buildConfiguration(configuration);\n    this.logger = this.config.system.logger;\n    this.clientId = this.config.auth.clientId;\n    this.inCookie = this.config.cache.storeAuthStateInCookie;\n    this.telemetryManager = this.getTelemetryManagerFromConfig(this.config.system.telemetry, this.clientId);\n    TrustedAuthority.setTrustedAuthoritiesFromConfig(this.config.auth.validateAuthority, this.config.auth.knownAuthorities);\n    AuthorityFactory.saveMetadataFromConfig(this.config.auth.authority, this.config.auth.authorityMetadata); // if no authority is passed, set the default: \"https://login.microsoftonline.com/common\"\n\n    this.authority = this.config.auth.authority || DEFAULT_AUTHORITY; // cache keys msal - typescript throws an error if any value other than \"localStorage\" or \"sessionStorage\" is passed\n\n    this.cacheStorage = new AuthCache(this.clientId, this.config.cache.cacheLocation, this.inCookie); // Initialize window handling code\n\n    if (!window.activeRenewals) {\n      window.activeRenewals = {};\n    }\n\n    if (!window.renewStates) {\n      window.renewStates = [];\n    }\n\n    if (!window.callbackMappedToRenewStates) {\n      window.callbackMappedToRenewStates = {};\n    }\n\n    if (!window.promiseMappedToRenewStates) {\n      window.promiseMappedToRenewStates = {};\n    }\n\n    window.msal = this;\n    var urlHash = window.location.hash;\n    var urlContainsHash = UrlUtils.urlContainsHash(urlHash); // check if back button is pressed\n\n    WindowUtils.checkIfBackButtonIsPressed(this.cacheStorage); // On the server 302 - Redirect, handle this\n\n    if (urlContainsHash && this.cacheStorage.isInteractionInProgress(true)) {\n      var stateInfo = this.getResponseState(urlHash);\n\n      if (stateInfo.method === Constants.interactionTypeRedirect) {\n        this.handleRedirectAuthenticationResponse(urlHash);\n      }\n    }\n  }\n\n  Object.defineProperty(UserAgentApplication.prototype, \"authority\", {\n    /**\n     * Method to manage the authority URL.\n     *\n     * @returns {string} authority\n     */\n    get: function get() {\n      return this.authorityInstance.CanonicalAuthority;\n    },\n\n    /**\n     * setter for the authority URL\n     * @param {string} authority\n     */\n    // If the developer passes an authority, create an instance\n    set: function set(val) {\n      this.authorityInstance = AuthorityFactory.CreateInstance(val, this.config.auth.validateAuthority);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Get the current authority instance from the MSAL configuration object\n   *\n   * @returns {@link Authority} authority instance\n   */\n\n  UserAgentApplication.prototype.getAuthorityInstance = function () {\n    return this.authorityInstance;\n  };\n\n  UserAgentApplication.prototype.handleRedirectCallback = function (authOrTokenCallback, errorReceivedCallback) {\n    if (!authOrTokenCallback) {\n      throw ClientConfigurationError.createInvalidCallbackObjectError(authOrTokenCallback);\n    } // Set callbacks\n\n\n    if (errorReceivedCallback) {\n      this.tokenReceivedCallback = authOrTokenCallback;\n      this.errorReceivedCallback = errorReceivedCallback;\n      this.logger.warning(\"This overload for callback is deprecated - please change the format of the callbacks to a single callback as shown: (err: AuthError, response: AuthResponse).\");\n    } else {\n      this.authResponseCallback = authOrTokenCallback;\n    }\n\n    if (this.redirectError) {\n      this.authErrorHandler(Constants.interactionTypeRedirect, this.redirectError, this.redirectResponse);\n    } else if (this.redirectResponse) {\n      this.authResponseHandler(Constants.interactionTypeRedirect, this.redirectResponse);\n    }\n  };\n  /**\n   * Public API to verify if the URL contains the hash with known properties\n   * @param hash\n   */\n\n\n  UserAgentApplication.prototype.urlContainsHash = function (hash) {\n    this.logger.verbose(\"UrlContainsHash has been called\");\n    return UrlUtils.urlContainsHash(hash);\n  };\n\n  UserAgentApplication.prototype.authResponseHandler = function (interactionType, response, resolve) {\n    this.logger.verbose(\"AuthResponseHandler has been called\");\n    this.cacheStorage.setInteractionInProgress(false);\n\n    if (interactionType === Constants.interactionTypeRedirect) {\n      this.logger.verbose(\"Interaction type is redirect\");\n\n      if (this.errorReceivedCallback) {\n        this.logger.verbose(\"Two callbacks were provided to handleRedirectCallback, calling success callback with response\");\n        this.tokenReceivedCallback(response);\n      } else if (this.authResponseCallback) {\n        this.logger.verbose(\"One callback was provided to handleRedirectCallback, calling authResponseCallback with response\");\n        this.authResponseCallback(null, response);\n      }\n    } else if (interactionType === Constants.interactionTypePopup) {\n      this.logger.verbose(\"Interaction type is popup, resolving\");\n      resolve(response);\n    } else {\n      throw ClientAuthError.createInvalidInteractionTypeError();\n    }\n  };\n\n  UserAgentApplication.prototype.authErrorHandler = function (interactionType, authErr, response, reject) {\n    this.logger.verbose(\"AuthErrorHandler has been called\"); // set interaction_status to complete\n\n    this.cacheStorage.setInteractionInProgress(false);\n\n    if (interactionType === Constants.interactionTypeRedirect) {\n      this.logger.verbose(\"Interaction type is redirect\");\n\n      if (this.errorReceivedCallback) {\n        this.logger.verbose(\"Two callbacks were provided to handleRedirectCallback, calling error callback\");\n        this.errorReceivedCallback(authErr, response.accountState);\n      } else if (this.authResponseCallback) {\n        this.logger.verbose(\"One callback was provided to handleRedirectCallback, calling authResponseCallback with error\");\n        this.authResponseCallback(authErr, response);\n      } else {\n        this.logger.verbose(\"handleRedirectCallback has not been called and no callbacks are registered, throwing error\");\n        throw authErr;\n      }\n    } else if (interactionType === Constants.interactionTypePopup) {\n      this.logger.verbose(\"Interaction type is popup, rejecting\");\n      reject(authErr);\n    } else {\n      throw ClientAuthError.createInvalidInteractionTypeError();\n    }\n  }; // #endregion\n\n  /**\n   * Use when initiating the login process by redirecting the user's browser to the authorization endpoint.\n   * @param {@link (AuthenticationParameters:type)}\n   */\n\n\n  UserAgentApplication.prototype.loginRedirect = function (userRequest) {\n    this.logger.verbose(\"LoginRedirect has been called\"); // validate request\n\n    var request = RequestUtils.validateRequest(userRequest, true, this.clientId, Constants.interactionTypeRedirect);\n    this.acquireTokenInteractive(Constants.interactionTypeRedirect, true, request, null, null);\n  };\n  /**\n   * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint.\n   * @param {@link (AuthenticationParameters:type)}\n   *\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\n   */\n\n\n  UserAgentApplication.prototype.acquireTokenRedirect = function (userRequest) {\n    this.logger.verbose(\"AcquireTokenRedirect has been called\"); // validate request\n\n    var request = RequestUtils.validateRequest(userRequest, false, this.clientId, Constants.interactionTypeRedirect);\n    this.acquireTokenInteractive(Constants.interactionTypeRedirect, false, request, null, null);\n  };\n  /**\n   * Use when initiating the login process via opening a popup window in the user's browser\n   *\n   * @param {@link (AuthenticationParameters:type)}\n   *\n   * @returns {Promise.<AuthResponse>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object\n   */\n\n\n  UserAgentApplication.prototype.loginPopup = function (userRequest) {\n    var _this = this;\n\n    this.logger.verbose(\"LoginPopup has been called\"); // validate request\n\n    var request = RequestUtils.validateRequest(userRequest, true, this.clientId, Constants.interactionTypePopup);\n    var apiEvent = this.telemetryManager.createAndStartApiEvent(request.correlationId, API_EVENT_IDENTIFIER.LoginPopup);\n    return new Promise(function (resolve, reject) {\n      _this.acquireTokenInteractive(Constants.interactionTypePopup, true, request, resolve, reject);\n    }).then(function (resp) {\n      _this.logger.verbose(\"Successfully logged in\");\n\n      _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, true);\n\n      return resp;\n    }).catch(function (error) {\n      _this.cacheStorage.resetTempCacheItems(request.state);\n\n      _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, false, error.errorCode);\n\n      throw error;\n    });\n  };\n  /**\n   * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser\n   * @param {@link AuthenticationParameters}\n   *\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\n   * @returns {Promise.<AuthResponse>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object\n   */\n\n\n  UserAgentApplication.prototype.acquireTokenPopup = function (userRequest) {\n    var _this = this;\n\n    this.logger.verbose(\"AcquireTokenPopup has been called\"); // validate request\n\n    var request = RequestUtils.validateRequest(userRequest, false, this.clientId, Constants.interactionTypePopup);\n    var apiEvent = this.telemetryManager.createAndStartApiEvent(request.correlationId, API_EVENT_IDENTIFIER.AcquireTokenPopup);\n    return new Promise(function (resolve, reject) {\n      _this.acquireTokenInteractive(Constants.interactionTypePopup, false, request, resolve, reject);\n    }).then(function (resp) {\n      _this.logger.verbose(\"Successfully acquired token\");\n\n      _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, true);\n\n      return resp;\n    }).catch(function (error) {\n      _this.cacheStorage.resetTempCacheItems(request.state);\n\n      _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, false, error.errorCode);\n\n      throw error;\n    });\n  }; // #region Acquire Token\n\n  /**\n   * Use when initiating the login process or when you want to obtain an access_token for your API,\n   * either by redirecting the user's browser window to the authorization endpoint or via opening a popup window in the user's browser.\n   * @param {@link (AuthenticationParameters:type)}\n   *\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\n   */\n\n\n  UserAgentApplication.prototype.acquireTokenInteractive = function (interactionType, isLoginCall, request, resolve, reject) {\n    var _this = this;\n\n    this.logger.verbose(\"AcquireTokenInteractive has been called\"); // block the request if made from the hidden iframe\n\n    WindowUtils.blockReloadInHiddenIframes();\n\n    try {\n      this.cacheStorage.setInteractionInProgress(true);\n    } catch (e) {\n      // If already in progress, do not proceed\n      var thrownError = isLoginCall ? ClientAuthError.createLoginInProgressError() : ClientAuthError.createAcquireTokenInProgressError();\n      var stateOnlyResponse = buildResponseStateOnly(this.getAccountState(request.state));\n      this.cacheStorage.resetTempCacheItems(request.state);\n      this.authErrorHandler(interactionType, thrownError, stateOnlyResponse, reject);\n      return;\n    }\n\n    if (interactionType === Constants.interactionTypeRedirect) {\n      this.cacheStorage.setItem(TemporaryCacheKeys.REDIRECT_REQUEST, \"\" + Constants.inProgress + Constants.resourceDelimiter + request.state);\n    } // Get the account object if a session exists\n\n\n    var account;\n\n    if (request && request.account && !isLoginCall) {\n      account = request.account;\n      this.logger.verbose(\"Account set from request\");\n    } else {\n      account = this.getAccount();\n      this.logger.verbose(\"Account set from MSAL Cache\");\n    } // If no session exists, prompt the user to login.\n\n\n    if (!account && !ServerRequestParameters.isSSOParam(request)) {\n      if (isLoginCall) {\n        // extract ADAL id_token if exists\n        var adalIdToken = this.extractADALIdToken(); // silent login if ADAL id_token is retrieved successfully - SSO\n\n        if (adalIdToken && !request.scopes) {\n          this.logger.info(\"ADAL's idToken exists. Extracting login information from ADAL's idToken\");\n          var tokenRequest = this.buildIDTokenRequest(request);\n          this.silentLogin = true;\n          this.acquireTokenSilent(tokenRequest).then(function (response) {\n            _this.silentLogin = false;\n\n            _this.logger.info(\"Unified cache call is successful\");\n\n            _this.authResponseHandler(interactionType, response, resolve);\n\n            return;\n          }, function (error) {\n            _this.silentLogin = false;\n\n            _this.logger.error(\"Error occurred during unified cache ATS: \" + error); // proceed to login since ATS failed\n\n\n            _this.acquireTokenHelper(null, interactionType, isLoginCall, request, resolve, reject);\n          });\n        } // No ADAL token found, proceed to login\n        else {\n            this.logger.verbose(\"Login call but no token found, proceed to login\");\n            this.acquireTokenHelper(null, interactionType, isLoginCall, request, resolve, reject);\n          }\n      } // AcquireToken call, but no account or context given, so throw error\n      else {\n          this.logger.verbose(\"AcquireToken call, no context or account given\");\n          this.logger.info(\"User login is required\");\n          var stateOnlyResponse = buildResponseStateOnly(this.getAccountState(request.state));\n          this.cacheStorage.resetTempCacheItems(request.state);\n          this.authErrorHandler(interactionType, ClientAuthError.createUserLoginRequiredError(), stateOnlyResponse, reject);\n          return;\n        }\n    } // User session exists\n    else {\n        this.logger.verbose(\"User session exists, login not required\");\n        this.acquireTokenHelper(account, interactionType, isLoginCall, request, resolve, reject);\n      }\n  };\n  /**\n   * @hidden\n   * @ignore\n   * Helper function to acquireToken\n   *\n   */\n\n\n  UserAgentApplication.prototype.acquireTokenHelper = function (account, interactionType, isLoginCall, request, resolve, reject) {\n    return __awaiter(this, void 0, void 0, function () {\n      var requestSignature, serverAuthenticationRequest, acquireTokenAuthority, popUpWindow, responseType, loginStartPage, urlNavigate, hash, error_1, navigate, err_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"AcquireTokenHelper has been called\");\n            this.logger.verbose(\"Interaction type: \" + interactionType + \". isLoginCall: \" + isLoginCall);\n            requestSignature = request.scopes ? request.scopes.join(\" \").toLowerCase() : Constants.oidcScopes.join(\" \");\n            this.logger.verbosePii(\"Request signature: \" + requestSignature);\n            acquireTokenAuthority = request && request.authority ? AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority, request.authorityMetadata) : this.authorityInstance;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 11,, 12]);\n\n            if (!!acquireTokenAuthority.hasCachedMetadata()) return [3\n            /*break*/\n            , 3];\n            this.logger.verbose(\"No cached metadata for authority\");\n            return [4\n            /*yield*/\n            , AuthorityFactory.saveMetadataFromNetwork(acquireTokenAuthority, this.telemetryManager, request.correlationId)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            this.logger.verbose(\"Cached metadata found for authority\");\n            _a.label = 4;\n\n          case 4:\n            responseType = isLoginCall ? ResponseTypes.id_token : this.getTokenType(account, request.scopes);\n            loginStartPage = request.redirectStartPage || window.location.href;\n            serverAuthenticationRequest = new ServerRequestParameters(acquireTokenAuthority, this.clientId, responseType, this.getRedirectUri(request && request.redirectUri), request.scopes, request.state, request.correlationId);\n            this.logger.verbose(\"Finished building server authentication request\");\n            this.updateCacheEntries(serverAuthenticationRequest, account, isLoginCall, loginStartPage);\n            this.logger.verbose(\"Updating cache entries\"); // populate QueryParameters (sid/login_hint) and any other extraQueryParameters set by the developer\n\n            serverAuthenticationRequest.populateQueryParams(account, request);\n            this.logger.verbose(\"Query parameters populated from account\");\n            urlNavigate = UrlUtils.createNavigateUrl(serverAuthenticationRequest) + Constants.response_mode_fragment; // set state in cache\n\n            if (interactionType === Constants.interactionTypeRedirect) {\n              if (!isLoginCall) {\n                this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_ACQ_TOKEN, request.state), serverAuthenticationRequest.state, this.inCookie);\n                this.logger.verbose(\"State cached for redirect\");\n                this.logger.verbosePii(\"State cached: \" + serverAuthenticationRequest.state);\n              } else {\n                this.logger.verbose(\"Interaction type redirect but login call is true. State not cached\");\n              }\n            } else if (interactionType === Constants.interactionTypePopup) {\n              window.renewStates.push(serverAuthenticationRequest.state);\n              window.requestType = isLoginCall ? Constants.login : Constants.renewToken;\n              this.logger.verbose(\"State saved to window\");\n              this.logger.verbosePii(\"State saved: \" + serverAuthenticationRequest.state); // Register callback to capture results from server\n\n              this.registerCallback(serverAuthenticationRequest.state, requestSignature, resolve, reject);\n            } else {\n              this.logger.verbose(\"Invalid interaction error. State not cached\");\n              throw ClientAuthError.createInvalidInteractionTypeError();\n            }\n\n            if (!(interactionType === Constants.interactionTypePopup)) return [3\n            /*break*/\n            , 9];\n            this.logger.verbose(\"Interaction type is popup. Generating popup window\"); // Generate a popup window\n\n            try {\n              popUpWindow = this.openPopup(urlNavigate, \"msal\", Constants.popUpWidth, Constants.popUpHeight); // Push popup window handle onto stack for tracking\n\n              WindowUtils.trackPopup(popUpWindow);\n            } catch (e) {\n              this.logger.info(ClientAuthErrorMessage.popUpWindowError.code + \":\" + ClientAuthErrorMessage.popUpWindowError.desc);\n              this.cacheStorage.setItem(ErrorCacheKeys.ERROR, ClientAuthErrorMessage.popUpWindowError.code);\n              this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, ClientAuthErrorMessage.popUpWindowError.desc);\n\n              if (reject) {\n                reject(ClientAuthError.createPopupWindowError());\n                return [2\n                /*return*/\n                ];\n              }\n            }\n\n            if (!popUpWindow) return [3\n            /*break*/\n            , 8];\n            _a.label = 5;\n\n          case 5:\n            _a.trys.push([5, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , WindowUtils.monitorPopupForHash(popUpWindow, this.config.system.loadFrameTimeout, urlNavigate, this.logger)];\n\n          case 6:\n            hash = _a.sent();\n            this.handleAuthenticationResponse(hash); // Request completed successfully, set to completed\n\n            this.cacheStorage.setInteractionInProgress(false);\n            this.logger.info(\"Closing popup window\"); // TODO: Check how this can be extracted for any framework specific code?\n\n            if (this.config.framework.isAngular) {\n              this.broadcast(\"msal:popUpHashChanged\", hash);\n            }\n\n            WindowUtils.closePopups();\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            error_1 = _a.sent();\n\n            if (reject) {\n              reject(error_1);\n            }\n\n            if (this.config.framework.isAngular) {\n              this.broadcast(\"msal:popUpClosed\", error_1.errorCode + Constants.resourceDelimiter + error_1.errorMessage);\n            } else {\n              // Request failed, set to canceled\n              this.cacheStorage.setInteractionInProgress(false);\n              popUpWindow.close();\n            }\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            // If onRedirectNavigate is implemented, invoke it and provide urlNavigate\n            if (request.onRedirectNavigate) {\n              this.logger.verbose(\"Invoking onRedirectNavigate callback\");\n              navigate = request.onRedirectNavigate(urlNavigate); // Returning false from onRedirectNavigate will stop navigation\n\n              if (navigate !== false) {\n                this.logger.verbose(\"onRedirectNavigate did not return false, navigating\");\n                this.navigateWindow(urlNavigate);\n              } else {\n                this.logger.verbose(\"onRedirectNavigate returned false, stopping navigation\");\n              }\n            } else {\n              // Otherwise, perform navigation\n              this.logger.verbose(\"Navigating window to urlNavigate\");\n              this.navigateWindow(urlNavigate);\n            }\n\n            _a.label = 10;\n\n          case 10:\n            return [3\n            /*break*/\n            , 12];\n\n          case 11:\n            err_1 = _a.sent();\n            this.logger.error(err_1);\n            this.cacheStorage.resetTempCacheItems(request.state);\n            this.authErrorHandler(interactionType, ClientAuthError.createEndpointResolutionError(err_1.toString), buildResponseStateOnly(request.state), reject);\n\n            if (popUpWindow) {\n              popUpWindow.close();\n            }\n\n            return [3\n            /*break*/\n            , 12];\n\n          case 12:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * API interfacing idToken request when applications already have a session/hint acquired by authorization client applications\n   * @param request\n   */\n\n\n  UserAgentApplication.prototype.ssoSilent = function (request) {\n    this.logger.verbose(\"ssoSilent has been called\"); // throw an error on an empty request\n\n    if (!request) {\n      throw ClientConfigurationError.createEmptyRequestError();\n    } // throw an error on no hints passed\n\n\n    if (!request.sid && !request.loginHint) {\n      throw ClientConfigurationError.createSsoSilentError();\n    }\n\n    return this.acquireTokenSilent(__assign(__assign({}, request), {\n      scopes: Constants.oidcScopes\n    }));\n  };\n  /**\n   * Use this function to obtain a token before every call to the API / resource provider\n   *\n   * MSAL return's a cached token when available\n   * Or it send's a request to the STS to obtain a new token using a hidden iframe.\n   *\n   * @param {@link AuthenticationParameters}\n   *\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\n   * @returns {Promise.<AuthResponse>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object\n   *\n   */\n\n\n  UserAgentApplication.prototype.acquireTokenSilent = function (userRequest) {\n    var _this = this;\n\n    this.logger.verbose(\"AcquireTokenSilent has been called\"); // validate the request\n\n    var request = RequestUtils.validateRequest(userRequest, false, this.clientId, Constants.interactionTypeSilent);\n    var apiEvent = this.telemetryManager.createAndStartApiEvent(request.correlationId, API_EVENT_IDENTIFIER.AcquireTokenSilent);\n    var requestSignature = RequestUtils.createRequestSignature(request);\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var scope, account, adalIdToken, responseType, serverAuthenticationRequest, adalIdTokenObject, userContainedClaims, authErr, cacheResultResponse, logMessage, err_2;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              // block the request if made from the hidden iframe\n              WindowUtils.blockReloadInHiddenIframes();\n              scope = request.scopes.join(\" \").toLowerCase();\n              this.logger.verbosePii(\"Serialized scopes: \" + scope);\n\n              if (request.account) {\n                account = request.account;\n                this.logger.verbose(\"Account set from request\");\n              } else {\n                account = this.getAccount();\n                this.logger.verbose(\"Account set from MSAL Cache\");\n              }\n\n              adalIdToken = this.cacheStorage.getItem(Constants.adalIdToken); // In the event of no account being passed in the config, no session id, and no pre-existing adalIdToken, user will need to log in\n\n              if (!account && !(request.sid || request.loginHint) && StringUtils.isEmpty(adalIdToken)) {\n                this.logger.info(\"User login is required\"); // The promise rejects with a UserLoginRequiredError, which should be caught and user should be prompted to log in interactively\n\n                return [2\n                /*return*/\n                , reject(ClientAuthError.createUserLoginRequiredError())];\n              }\n\n              responseType = this.getTokenType(account, request.scopes);\n              this.logger.verbose(\"Response type: \" + responseType);\n              serverAuthenticationRequest = new ServerRequestParameters(AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority, request.authorityMetadata), this.clientId, responseType, this.getRedirectUri(request.redirectUri), request.scopes, request.state, request.correlationId);\n              this.logger.verbose(\"Finished building server authentication request\"); // populate QueryParameters (sid/login_hint) and any other extraQueryParameters set by the developer\n\n              if (ServerRequestParameters.isSSOParam(request) || account) {\n                serverAuthenticationRequest.populateQueryParams(account, request, null, true);\n                this.logger.verbose(\"Query parameters populated from existing SSO or account\");\n              } // if user didn't pass login_hint/sid and adal's idtoken is present, extract the login_hint from the adalIdToken\n              else if (!account && !StringUtils.isEmpty(adalIdToken)) {\n                  adalIdTokenObject = TokenUtils.extractIdToken(adalIdToken);\n                  this.logger.verbose(\"ADAL's idToken exists. Extracting login information from ADAL's idToken to populate query parameters\");\n                  serverAuthenticationRequest.populateQueryParams(account, null, adalIdTokenObject, true);\n                } else {\n                  this.logger.verbose(\"No additional query parameters added\");\n                }\n\n              userContainedClaims = request.claimsRequest || serverAuthenticationRequest.claimsValue; // If request.forceRefresh is set to true, force a request for a new token instead of getting it from the cache\n\n              if (!userContainedClaims && !request.forceRefresh) {\n                try {\n                  cacheResultResponse = this.getCachedToken(serverAuthenticationRequest, account);\n                } catch (e) {\n                  authErr = e;\n                }\n              }\n\n              if (!cacheResultResponse) return [3\n              /*break*/\n              , 1];\n              this.logger.verbose(\"Token found in cache lookup\");\n              this.logger.verbosePii(\"Scopes found: \" + JSON.stringify(cacheResultResponse.scopes));\n              resolve(cacheResultResponse);\n              return [2\n              /*return*/\n              , null];\n\n            case 1:\n              if (!authErr) return [3\n              /*break*/\n              , 2];\n              this.logger.infoPii(authErr.errorCode + \":\" + authErr.errorMessage);\n              reject(authErr);\n              return [2\n              /*return*/\n              , null];\n\n            case 2:\n              logMessage = void 0;\n\n              if (userContainedClaims) {\n                logMessage = \"Skipped cache lookup since claims were given\";\n              } else if (request.forceRefresh) {\n                logMessage = \"Skipped cache lookup since request.forceRefresh option was set to true\";\n              } else {\n                logMessage = \"No valid token found in cache lookup\";\n              }\n\n              this.logger.verbose(logMessage); // Cache result can return null if cache is empty. In that case, set authority to default value if no authority is passed to the API.\n\n              if (!serverAuthenticationRequest.authorityInstance) {\n                serverAuthenticationRequest.authorityInstance = request.authority ? AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority, request.authorityMetadata) : this.authorityInstance;\n              }\n\n              this.logger.verbosePii(\"Authority instance: \" + serverAuthenticationRequest.authority);\n              _a.label = 3;\n\n            case 3:\n              _a.trys.push([3, 7,, 8]);\n\n              if (!!serverAuthenticationRequest.authorityInstance.hasCachedMetadata()) return [3\n              /*break*/\n              , 5];\n              this.logger.verbose(\"No cached metadata for authority\");\n              return [4\n              /*yield*/\n              , AuthorityFactory.saveMetadataFromNetwork(serverAuthenticationRequest.authorityInstance, this.telemetryManager, request.correlationId)];\n\n            case 4:\n              _a.sent();\n\n              this.logger.verbose(\"Authority has been updated with endpoint discovery response\");\n              return [3\n              /*break*/\n              , 6];\n\n            case 5:\n              this.logger.verbose(\"Cached metadata found for authority\");\n              _a.label = 6;\n\n            case 6:\n              /*\n               * refresh attempt with iframe\n               * Already renewing for this scope, callback when we get the token.\n               */\n              if (window.activeRenewals[requestSignature]) {\n                this.logger.verbose(\"Renewing token in progress. Registering callback\"); // Active renewals contains the state for each renewal.\n\n                this.registerCallback(window.activeRenewals[requestSignature], requestSignature, resolve, reject);\n              } else {\n                if (request.scopes && ScopeSet.onlyContainsOidcScopes(request.scopes)) {\n                  /*\n                   * App uses idToken to send to api endpoints\n                   * Default scope is tracked as OIDC scopes to store this token\n                   */\n                  this.logger.verbose(\"OpenID Connect scopes only, renewing idToken\");\n                  this.silentLogin = true;\n                  this.renewIdToken(requestSignature, resolve, reject, account, serverAuthenticationRequest);\n                } else {\n                  // renew access token\n                  this.logger.verbose(\"Renewing access token\");\n                  this.renewToken(requestSignature, resolve, reject, account, serverAuthenticationRequest);\n                }\n              }\n\n              return [3\n              /*break*/\n              , 8];\n\n            case 7:\n              err_2 = _a.sent();\n              this.logger.error(err_2);\n              reject(ClientAuthError.createEndpointResolutionError(err_2.toString()));\n              return [2\n              /*return*/\n              , null];\n\n            case 8:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }).then(function (res) {\n      _this.logger.verbose(\"Successfully acquired token\");\n\n      _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, true);\n\n      return res;\n    }).catch(function (error) {\n      _this.cacheStorage.resetTempCacheItems(request.state);\n\n      _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, false, error.errorCode);\n\n      throw error;\n    });\n  }; // #endregion\n  // #region Popup Window Creation\n\n  /**\n   * @hidden\n   *\n   * Configures popup window for login.\n   *\n   * @param urlNavigate\n   * @param title\n   * @param popUpWidth\n   * @param popUpHeight\n   * @ignore\n   * @hidden\n   */\n\n\n  UserAgentApplication.prototype.openPopup = function (urlNavigate, title, popUpWidth, popUpHeight) {\n    this.logger.verbose(\"OpenPopup has been called\");\n\n    try {\n      /**\n       * adding winLeft and winTop to account for dual monitor\n       * using screenLeft and screenTop for IE8 and earlier\n       */\n      var winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n      var winTop = window.screenTop ? window.screenTop : window.screenY;\n      /**\n       * window.innerWidth displays browser window\"s height and width excluding toolbars\n       * using document.documentElement.clientWidth for IE8 and earlier\n       */\n\n      var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n      var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n      var left = width / 2 - popUpWidth / 2 + winLeft;\n      var top_1 = height / 2 - popUpHeight / 2 + winTop; // open the window\n\n      var popupWindow = window.open(urlNavigate, title, \"width=\" + popUpWidth + \", height=\" + popUpHeight + \", top=\" + top_1 + \", left=\" + left + \", scrollbars=yes\");\n\n      if (!popupWindow) {\n        throw ClientAuthError.createPopupWindowError();\n      }\n\n      if (popupWindow.focus) {\n        popupWindow.focus();\n      }\n\n      return popupWindow;\n    } catch (e) {\n      this.cacheStorage.setInteractionInProgress(false);\n      throw ClientAuthError.createPopupWindowError(e.toString());\n    }\n  }; // #endregion\n  // #region Iframe Management\n\n  /**\n   * @hidden\n   * Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left.\n   * registered when network errors occur and subsequent token requests for same resource are registered to the pending request.\n   * @ignore\n   */\n\n\n  UserAgentApplication.prototype.loadIframeTimeout = function (urlNavigate, frameName, requestSignature) {\n    return __awaiter(this, void 0, void 0, function () {\n      var expectedState, iframe, _a, hash, error_2;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            expectedState = window.activeRenewals[requestSignature];\n            this.logger.verbosePii(\"Set loading state to pending for: \" + requestSignature + \":\" + expectedState);\n            this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, expectedState), Constants.inProgress);\n            if (!this.config.system.navigateFrameWait) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , WindowUtils.loadFrame(urlNavigate, frameName, this.config.system.navigateFrameWait, this.logger)];\n\n          case 1:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            _a = WindowUtils.loadFrameSync(urlNavigate, frameName, this.logger);\n            _b.label = 3;\n\n          case 3:\n            iframe = _a;\n            _b.label = 4;\n\n          case 4:\n            _b.trys.push([4, 6,, 7]);\n\n            return [4\n            /*yield*/\n            , WindowUtils.monitorIframeForHash(iframe.contentWindow, this.config.system.loadFrameTimeout, urlNavigate, this.logger)];\n\n          case 5:\n            hash = _b.sent();\n\n            if (hash) {\n              this.handleAuthenticationResponse(hash);\n            }\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            error_2 = _b.sent();\n\n            if (this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, expectedState)) === Constants.inProgress) {\n              // fail the iframe session if it's in pending state\n              this.logger.verbose(\"Loading frame has timed out after: \" + this.config.system.loadFrameTimeout / 1000 + \" seconds for scope/authority \" + requestSignature + \":\" + expectedState); // Error after timeout\n\n              if (expectedState && window.callbackMappedToRenewStates[expectedState]) {\n                window.callbackMappedToRenewStates[expectedState](null, error_2);\n              }\n\n              this.cacheStorage.removeItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, expectedState));\n            }\n\n            WindowUtils.removeHiddenIframe(iframe);\n            throw error_2;\n\n          case 7:\n            WindowUtils.removeHiddenIframe(iframe);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // #endregion\n  // #region General Helpers\n\n  /**\n   * @hidden\n   * Used to redirect the browser to the STS authorization endpoint\n   * @param {string} urlNavigate - URL of the authorization endpoint\n   */\n\n\n  UserAgentApplication.prototype.navigateWindow = function (urlNavigate, popupWindow) {\n    // Navigate if valid URL\n    if (urlNavigate && !StringUtils.isEmpty(urlNavigate)) {\n      var navigateWindow = popupWindow ? popupWindow : window;\n      var logMessage = popupWindow ? \"Navigated Popup window to:\" + urlNavigate : \"Navigate to:\" + urlNavigate;\n      this.logger.infoPii(logMessage);\n      navigateWindow.location.assign(urlNavigate);\n    } else {\n      this.logger.info(\"Navigate url is empty\");\n      throw AuthError.createUnexpectedError(\"Navigate url is empty\");\n    }\n  };\n  /**\n   * @hidden\n   * Used to add the developer requested callback to the array of callbacks for the specified scopes. The updated array is stored on the window object\n   * @param {string} expectedState - Unique state identifier (guid).\n   * @param {string} scope - Developer requested permissions. Not all scopes are guaranteed to be included in the access token returned.\n   * @param {Function} resolve - The resolve function of the promise object.\n   * @param {Function} reject - The reject function of the promise object.\n   * @ignore\n   */\n\n\n  UserAgentApplication.prototype.registerCallback = function (expectedState, requestSignature, resolve, reject) {\n    var _this = this; // track active renewals\n\n\n    window.activeRenewals[requestSignature] = expectedState; // initialize callbacks mapped array\n\n    if (!window.promiseMappedToRenewStates[expectedState]) {\n      window.promiseMappedToRenewStates[expectedState] = [];\n    } // indexing on the current state, push the callback params to callbacks mapped\n\n\n    window.promiseMappedToRenewStates[expectedState].push({\n      resolve: resolve,\n      reject: reject\n    }); // Store the server response in the current window??\n\n    if (!window.callbackMappedToRenewStates[expectedState]) {\n      window.callbackMappedToRenewStates[expectedState] = function (response, error) {\n        // reset active renewals\n        delete window.activeRenewals[requestSignature]; // for all promiseMappedtoRenewStates for a given 'state' - call the reject/resolve with error/token respectively\n\n        for (var i = 0; i < window.promiseMappedToRenewStates[expectedState].length; ++i) {\n          try {\n            if (error) {\n              window.promiseMappedToRenewStates[expectedState][i].reject(error);\n            } else if (response) {\n              window.promiseMappedToRenewStates[expectedState][i].resolve(response);\n            } else {\n              _this.cacheStorage.resetTempCacheItems(expectedState);\n\n              throw AuthError.createUnexpectedError(\"Error and response are both null\");\n            }\n          } catch (e) {\n            _this.logger.warning(e);\n          }\n        } // reset\n\n\n        delete window.promiseMappedToRenewStates[expectedState];\n        delete window.callbackMappedToRenewStates[expectedState];\n      };\n    }\n  }; // #endregion\n  // #region Logout\n\n  /**\n   * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\n   * Default behaviour is to redirect the user to `window.location.href`.\n   */\n\n\n  UserAgentApplication.prototype.logout = function (correlationId) {\n    this.logger.verbose(\"Logout has been called\");\n    this.logoutAsync(correlationId);\n  };\n  /**\n   * Async version of logout(). Use to log out the current user.\n   * @param correlationId Request correlationId\n   */\n\n\n  UserAgentApplication.prototype.logoutAsync = function (correlationId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var requestCorrelationId, apiEvent, correlationIdParam, postLogoutQueryParam, urlNavigate, error_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            requestCorrelationId = correlationId || CryptoUtils.createNewGuid();\n            apiEvent = this.telemetryManager.createAndStartApiEvent(requestCorrelationId, API_EVENT_IDENTIFIER.Logout);\n            this.clearCache();\n            this.account = null;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 5,, 6]);\n\n            if (!!this.authorityInstance.hasCachedMetadata()) return [3\n            /*break*/\n            , 3];\n            this.logger.verbose(\"No cached metadata for authority\");\n            return [4\n            /*yield*/\n            , AuthorityFactory.saveMetadataFromNetwork(this.authorityInstance, this.telemetryManager, correlationId)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            this.logger.verbose(\"Cached metadata found for authority\");\n            _a.label = 4;\n\n          case 4:\n            correlationIdParam = \"client-request-id=\" + requestCorrelationId;\n            postLogoutQueryParam = void 0;\n\n            if (this.getPostLogoutRedirectUri()) {\n              postLogoutQueryParam = \"&post_logout_redirect_uri=\" + encodeURIComponent(this.getPostLogoutRedirectUri());\n              this.logger.verbose(\"redirectUri found and set\");\n            } else {\n              postLogoutQueryParam = \"\";\n              this.logger.verbose(\"No redirectUri set for app. postLogoutQueryParam is empty\");\n            }\n\n            urlNavigate = void 0;\n\n            if (this.authorityInstance.EndSessionEndpoint) {\n              urlNavigate = this.authorityInstance.EndSessionEndpoint + \"?\" + correlationIdParam + postLogoutQueryParam;\n              this.logger.verbose(\"EndSessionEndpoint found and urlNavigate set\");\n              this.logger.verbosePii(\"urlNavigate set to: \" + this.authorityInstance.EndSessionEndpoint);\n            } else {\n              urlNavigate = this.authority + \"oauth2/v2.0/logout?\" + correlationIdParam + postLogoutQueryParam;\n              this.logger.verbose(\"No endpoint, urlNavigate set to default\");\n            }\n\n            this.telemetryManager.stopAndFlushApiEvent(requestCorrelationId, apiEvent, true);\n            this.logger.verbose(\"Navigating window to urlNavigate\");\n            this.navigateWindow(urlNavigate);\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            error_3 = _a.sent();\n            this.telemetryManager.stopAndFlushApiEvent(requestCorrelationId, apiEvent, false, error_3.errorCode);\n            return [3\n            /*break*/\n            , 6];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   * Clear all access tokens and ID tokens in the cache.\n   * @ignore\n   */\n\n\n  UserAgentApplication.prototype.clearCache = function () {\n    this.logger.verbose(\"Clearing cache\");\n    window.renewStates = [];\n    var tokenCacheItems = this.cacheStorage.getAllTokens(Constants.clientId, Constants.homeAccountIdentifier);\n\n    for (var i = 0; i < tokenCacheItems.length; i++) {\n      this.cacheStorage.removeItem(JSON.stringify(tokenCacheItems[i].key));\n    }\n\n    this.cacheStorage.resetCacheItems();\n    this.cacheStorage.clearMsalCookie();\n    this.logger.verbose(\"Cache cleared\");\n  };\n  /**\n   * @hidden\n   * Clear a given access token from the cache.\n   *\n   * @param accessToken\n   */\n\n\n  UserAgentApplication.prototype.clearCacheForScope = function (accessToken) {\n    this.logger.verbose(\"Clearing access token from cache\");\n    var accessTokenItems = this.cacheStorage.getAllAccessTokens(Constants.clientId, Constants.homeAccountIdentifier);\n\n    for (var i = 0; i < accessTokenItems.length; i++) {\n      var token = accessTokenItems[i];\n\n      if (token.value.accessToken === accessToken) {\n        this.cacheStorage.removeItem(JSON.stringify(token.key));\n        this.logger.verbosePii(\"Access token removed: \" + token.key);\n      }\n    }\n  }; // #endregion\n  // #region Response\n\n  /**\n   * @hidden\n   * @ignore\n   * Checks if the redirect response is received from the STS. In case of redirect, the url fragment has either id_token, access_token or error.\n   * @param {string} hash - Hash passed from redirect page.\n   * @returns {Boolean} - true if response contains id_token, access_token or error, false otherwise.\n   */\n\n\n  UserAgentApplication.prototype.isCallback = function (hash) {\n    this.logger.info(\"isCallback will be deprecated in favor of urlContainsHash in MSAL.js v2.0.\");\n    this.logger.verbose(\"isCallback has been called\");\n    return UrlUtils.urlContainsHash(hash);\n  };\n  /**\n   * @hidden\n   * Used to call the constructor callback with the token/error\n   * @param {string} [hash=window.location.hash] - Hash fragment of Url.\n   */\n\n\n  UserAgentApplication.prototype.processCallBack = function (hash, respStateInfo, parentCallback) {\n    this.logger.info(\"ProcessCallBack has been called. Processing callback from redirect response\"); // get the state info from the hash\n\n    var stateInfo = respStateInfo;\n\n    if (!stateInfo) {\n      this.logger.verbose(\"StateInfo is null, getting stateInfo from hash\");\n      stateInfo = this.getResponseState(hash);\n    }\n\n    var response;\n    var authErr; // Save the token info from the hash\n\n    try {\n      response = this.saveTokenFromHash(hash, stateInfo);\n    } catch (err) {\n      authErr = err;\n    }\n\n    try {\n      // Clear the cookie in the hash\n      this.cacheStorage.clearMsalCookie(stateInfo.state);\n      var accountState = this.getAccountState(stateInfo.state);\n\n      if (response) {\n        if (stateInfo.requestType === Constants.renewToken || response.accessToken) {\n          if (window.parent !== window) {\n            this.logger.verbose(\"Window is in iframe, acquiring token silently\");\n          } else {\n            this.logger.verbose(\"Acquiring token interactive in progress\");\n          }\n\n          this.logger.verbose(\"Response tokenType set to \" + ServerHashParamKeys.ACCESS_TOKEN);\n          response.tokenType = ServerHashParamKeys.ACCESS_TOKEN;\n        } else if (stateInfo.requestType === Constants.login) {\n          this.logger.verbose(\"Response tokenType set to \" + ServerHashParamKeys.ID_TOKEN);\n          response.tokenType = ServerHashParamKeys.ID_TOKEN;\n        }\n\n        if (!parentCallback) {\n          this.logger.verbose(\"Setting redirectResponse\");\n          this.redirectResponse = response;\n          return;\n        }\n      } else if (!parentCallback) {\n        this.logger.verbose(\"Response is null, setting redirectResponse with state\");\n        this.redirectResponse = buildResponseStateOnly(accountState);\n        this.redirectError = authErr;\n        this.cacheStorage.resetTempCacheItems(stateInfo.state);\n        return;\n      }\n\n      this.logger.verbose(\"Calling callback provided to processCallback\");\n      parentCallback(response, authErr);\n    } catch (err) {\n      this.logger.error(\"Error occurred in token received callback function: \" + err);\n      throw ClientAuthError.createErrorInCallbackFunction(err.toString());\n    }\n  };\n  /**\n   * @hidden\n   * This method must be called for processing the response received from the STS if using popups or iframes. It extracts the hash, processes the token or error\n   * information and saves it in the cache. It then resolves the promises with the result.\n   * @param {string} [hash=window.location.hash] - Hash fragment of Url.\n   */\n\n\n  UserAgentApplication.prototype.handleAuthenticationResponse = function (hash) {\n    this.logger.verbose(\"HandleAuthenticationResponse has been called\"); // retrieve the hash\n\n    var locationHash = hash || window.location.hash; // if (window.parent !== window), by using self, window.parent becomes equal to window in getResponseState method specifically\n\n    var stateInfo = this.getResponseState(locationHash);\n    this.logger.verbose(\"Obtained state from response\");\n    var tokenResponseCallback = window.callbackMappedToRenewStates[stateInfo.state];\n    this.processCallBack(locationHash, stateInfo, tokenResponseCallback);\n  };\n  /**\n   * @hidden\n   * This method must be called for processing the response received from the STS when using redirect flows. It extracts the hash, processes the token or error\n   * information and saves it in the cache. The result can then be accessed by user registered callbacks.\n   * @param {string} [hash=window.location.hash] - Hash fragment of Url.\n   */\n\n\n  UserAgentApplication.prototype.handleRedirectAuthenticationResponse = function (hash) {\n    this.logger.info(\"Returned from redirect url\");\n    this.logger.verbose(\"HandleRedirectAuthenticationResponse has been called\"); // clear hash from window\n\n    WindowUtils.clearUrlFragment(window);\n    this.logger.verbose(\"Window.location.hash cleared\"); // if (window.parent !== window), by using self, window.parent becomes equal to window in getResponseState method specifically\n\n    var stateInfo = this.getResponseState(hash); // if set to navigate to loginRequest page post login\n\n    if (this.config.auth.navigateToLoginRequestUrl && window.parent === window) {\n      this.logger.verbose(\"Window.parent is equal to window, not in popup or iframe. Navigation to login request url after login turned on\");\n      var loginRequestUrl = this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.LOGIN_REQUEST, stateInfo.state), this.inCookie); // Redirect to home page if login request url is null (real null or the string null)\n\n      if (!loginRequestUrl || loginRequestUrl === \"null\") {\n        this.logger.error(\"Unable to get valid login request url from cache, redirecting to home page\");\n        window.location.assign(\"/\");\n        return;\n      } else {\n        this.logger.verbose(\"Valid login request url obtained from cache\");\n        var currentUrl = UrlUtils.removeHashFromUrl(window.location.href);\n        var finalRedirectUrl = UrlUtils.removeHashFromUrl(loginRequestUrl);\n\n        if (currentUrl !== finalRedirectUrl) {\n          this.logger.verbose(\"Current url is not login request url, navigating\");\n          this.logger.verbosePii(\"CurrentUrl: \" + currentUrl + \", finalRedirectUrl: \" + finalRedirectUrl);\n          window.location.assign(\"\" + finalRedirectUrl + hash);\n          return;\n        } else {\n          this.logger.verbose(\"Current url matches login request url\");\n          var loginRequestUrlComponents = UrlUtils.GetUrlComponents(loginRequestUrl);\n\n          if (loginRequestUrlComponents.Hash) {\n            this.logger.verbose(\"Login request url contains hash, resetting non-msal hash\");\n            window.location.hash = loginRequestUrlComponents.Hash;\n          }\n        }\n      }\n    } else if (!this.config.auth.navigateToLoginRequestUrl) {\n      this.logger.verbose(\"Default navigation to start page after login turned off\");\n    }\n\n    this.processCallBack(hash, stateInfo, null);\n  };\n  /**\n   * @hidden\n   * Creates a stateInfo object from the URL fragment and returns it.\n   * @param {string} hash  -  Hash passed from redirect page\n   * @returns {TokenResponse} an object created from the redirect response from AAD comprising of the keys - parameters, requestType, stateMatch, stateResponse and valid.\n   * @ignore\n   */\n\n\n  UserAgentApplication.prototype.getResponseState = function (hash) {\n    this.logger.verbose(\"GetResponseState has been called\");\n    var parameters = UrlUtils.deserializeHash(hash);\n    var stateResponse;\n\n    if (!parameters) {\n      throw AuthError.createUnexpectedError(\"Hash was not parsed correctly.\");\n    }\n\n    if (parameters.hasOwnProperty(ServerHashParamKeys.STATE)) {\n      this.logger.verbose(\"Hash contains state. Creating stateInfo object\");\n      var parsedState = RequestUtils.parseLibraryState(parameters[\"state\"]);\n      stateResponse = {\n        requestType: Constants.unknown,\n        state: parameters[\"state\"],\n        timestamp: parsedState.ts,\n        method: parsedState.method,\n        stateMatch: false\n      };\n    } else {\n      throw AuthError.createUnexpectedError(\"Hash does not contain state.\");\n    }\n    /*\n     * async calls can fire iframe and login request at the same time if developer does not use the API as expected\n     * incoming callback needs to be looked up to find the request type\n     */\n    // loginRedirect\n\n\n    if (stateResponse.state === this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, stateResponse.state), this.inCookie) || stateResponse.state === this.silentAuthenticationState) {\n      this.logger.verbose(\"State matches cached state, setting requestType to login\");\n      stateResponse.requestType = Constants.login;\n      stateResponse.stateMatch = true;\n      return stateResponse;\n    } // acquireTokenRedirect\n    else if (stateResponse.state === this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_ACQ_TOKEN, stateResponse.state), this.inCookie)) {\n        this.logger.verbose(\"State matches cached state, setting requestType to renewToken\");\n        stateResponse.requestType = Constants.renewToken;\n        stateResponse.stateMatch = true;\n        return stateResponse;\n      } // external api requests may have many renewtoken requests for different resource\n\n\n    if (!stateResponse.stateMatch) {\n      this.logger.verbose(\"State does not match cached state, setting requestType to type from window\");\n      stateResponse.requestType = window.requestType;\n      var statesInParentContext = window.renewStates;\n\n      for (var i = 0; i < statesInParentContext.length; i++) {\n        if (statesInParentContext[i] === stateResponse.state) {\n          this.logger.verbose(\"Matching state found for request\");\n          stateResponse.stateMatch = true;\n          break;\n        }\n      }\n\n      if (!stateResponse.stateMatch) {\n        this.logger.verbose(\"Matching state not found for request\");\n      }\n    }\n\n    return stateResponse;\n  }; // #endregion\n  // #region Token Processing (Extract to TokenProcessing.ts)\n\n  /**\n   * @hidden\n   * Used to get token for the specified set of scopes from the cache\n   * @param {@link ServerRequestParameters} - Request sent to the STS to obtain an id_token/access_token\n   * @param {Account} account - Account for which the scopes were requested\n   */\n\n\n  UserAgentApplication.prototype.getCachedToken = function (serverAuthenticationRequest, account) {\n    this.logger.verbose(\"GetCachedToken has been called\");\n    var scopes = serverAuthenticationRequest.scopes;\n    /**\n     * Id Token should be returned in every acquireTokenSilent call. The only exception is a response_type = token\n     * request when a valid ID Token is not present in the cache.\n     */\n\n    var idToken = this.getCachedIdToken(serverAuthenticationRequest, account);\n    var authResponse = this.getCachedAccessToken(serverAuthenticationRequest, account, scopes);\n    var accountState = this.getAccountState(serverAuthenticationRequest.state);\n    return ResponseUtils.buildAuthResponse(idToken, authResponse, serverAuthenticationRequest, account, scopes, accountState);\n  };\n  /**\n   * @hidden\n   *\n   * Uses passed in authority to further filter an array of tokenCacheItems until only the token being searched for remains, then returns that tokenCacheItem.\n   * This method will throw if authority filtering still yields multiple matching tokens and will return null if not tokens match the authority passed in.\n   *\n   * @param authority\n   * @param tokenCacheItems\n   * @param request\n   * @param requestScopes\n   * @param tokenType\n   */\n\n\n  UserAgentApplication.prototype.getTokenCacheItemByAuthority = function (authority, tokenCacheItems, requestScopes, tokenType) {\n    var _this = this;\n\n    var filteredAuthorityItems;\n\n    if (UrlUtils.isCommonAuthority(authority) || UrlUtils.isOrganizationsAuthority(authority) || UrlUtils.isConsumersAuthority(authority)) {\n      filteredAuthorityItems = AuthCacheUtils.filterTokenCacheItemsByDomain(tokenCacheItems, UrlUtils.GetUrlComponents(authority).HostNameAndPort);\n    } else {\n      filteredAuthorityItems = AuthCacheUtils.filterTokenCacheItemsByAuthority(tokenCacheItems, authority);\n    }\n\n    if (filteredAuthorityItems.length === 1) {\n      return filteredAuthorityItems[0];\n    } else if (filteredAuthorityItems.length > 1) {\n      this.logger.warning(\"Multiple matching tokens found. Cleaning cache and requesting a new token.\");\n      filteredAuthorityItems.forEach(function (accessTokenCacheItem) {\n        _this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));\n      });\n      return null;\n    } else {\n      this.logger.verbose(\"No matching tokens of type \" + tokenType + \" found\");\n      return null;\n    }\n  };\n  /**\n   *\n   * @hidden\n   *\n   * Searches the token cache for an ID Token that matches the request parameter and returns it as an IdToken object.\n   *\n   * @param serverAuthenticationRequest\n   * @param account\n   */\n\n\n  UserAgentApplication.prototype.getCachedIdToken = function (serverAuthenticationRequest, account) {\n    this.logger.verbose(\"Getting all cached tokens of type ID Token\");\n    var idTokenCacheItems = this.cacheStorage.getAllIdTokens(this.clientId, account ? account.homeAccountIdentifier : null);\n    var matchAuthority = serverAuthenticationRequest.authority || this.authority;\n    var idTokenCacheItem = this.getTokenCacheItemByAuthority(matchAuthority, idTokenCacheItems, null, ServerHashParamKeys.ID_TOKEN);\n\n    if (idTokenCacheItem) {\n      this.logger.verbose(\"Evaluating ID token found\");\n      var idTokenIsStillValid = this.evaluateTokenExpiration(idTokenCacheItem);\n\n      if (idTokenIsStillValid) {\n        this.logger.verbose(\"ID token expiration is within offset, using ID token found in cache\");\n        var idTokenValue = idTokenCacheItem.value;\n\n        if (idTokenValue) {\n          this.logger.verbose(\"ID Token found in cache is valid and unexpired\");\n        } else {\n          this.logger.verbose(\"ID Token found in cache is invalid\");\n        }\n\n        return idTokenValue ? new IdToken(idTokenValue.idToken) : null;\n      } else {\n        this.logger.verbose(\"Cached ID token is expired, removing from cache\");\n        this.cacheStorage.removeItem(JSON.stringify(idTokenCacheItem.key));\n        return null;\n      }\n    } else {\n      this.logger.verbose(\"No tokens found\");\n      return null;\n    }\n  };\n  /**\n   *\n   * @hidden\n   *\n   * Searches the token cache for an access token that matches the request parameters and returns it as an AuthResponse.\n   *\n   * @param serverAuthenticationRequest\n   * @param account\n   * @param scopes\n   */\n\n\n  UserAgentApplication.prototype.getCachedAccessToken = function (serverAuthenticationRequest, account, scopes) {\n    this.logger.verbose(\"Getting all cached tokens of type Access Token\");\n    var tokenCacheItems = this.cacheStorage.getAllAccessTokens(this.clientId, account ? account.homeAccountIdentifier : null);\n    var scopeFilteredTokenCacheItems = AuthCacheUtils.filterTokenCacheItemsByScope(tokenCacheItems, scopes);\n    var matchAuthority = serverAuthenticationRequest.authority || this.authority; // serverAuthenticationRequest.authority can only be common or organizations if not null\n\n    var accessTokenCacheItem = this.getTokenCacheItemByAuthority(matchAuthority, scopeFilteredTokenCacheItems, scopes, ServerHashParamKeys.ACCESS_TOKEN);\n\n    if (!accessTokenCacheItem) {\n      this.logger.verbose(\"No matching token found when filtering by scope and authority\");\n      return null;\n    } else {\n      serverAuthenticationRequest.authorityInstance = AuthorityFactory.CreateInstance(accessTokenCacheItem.key.authority, this.config.auth.validateAuthority);\n      this.logger.verbose(\"Evaluating access token found\");\n      var tokenIsStillValid = this.evaluateTokenExpiration(accessTokenCacheItem); // The response value will stay null if token retrieved from the cache is expired, otherwise it will be populated with said token's data\n\n      if (tokenIsStillValid) {\n        this.logger.verbose(\"Access token expiration is within offset, using access token found in cache\");\n        var responseAccount = account || this.getAccount();\n\n        if (!responseAccount) {\n          throw AuthError.createUnexpectedError(\"Account should not be null here.\");\n        }\n\n        var aState = this.getAccountState(serverAuthenticationRequest.state);\n        var response = {\n          uniqueId: \"\",\n          tenantId: \"\",\n          tokenType: ServerHashParamKeys.ACCESS_TOKEN,\n          idToken: null,\n          idTokenClaims: null,\n          accessToken: accessTokenCacheItem.value.accessToken,\n          scopes: accessTokenCacheItem.key.scopes.split(\" \"),\n          expiresOn: new Date(Number(accessTokenCacheItem.value.expiresIn) * 1000),\n          account: responseAccount,\n          accountState: aState,\n          fromCache: true\n        };\n        return response;\n      } else {\n        this.logger.verbose(\"Access token expired, removing from cache\");\n        this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));\n        return null;\n      }\n    }\n  };\n  /**\n   * Returns true if the token passed in is within the acceptable expiration time offset, false if it is expired.\n   * @param tokenCacheItem\n   * @param serverAuthenticationRequest\n   */\n\n\n  UserAgentApplication.prototype.evaluateTokenExpiration = function (tokenCacheItem) {\n    var expiration = Number(tokenCacheItem.value.expiresIn);\n    return TokenUtils.validateExpirationIsWithinOffset(expiration, this.config.system.tokenRenewalOffsetSeconds);\n  };\n  /**\n   * @hidden\n   * Check if ADAL id_token exists and return if exists.\n   *\n   */\n\n\n  UserAgentApplication.prototype.extractADALIdToken = function () {\n    this.logger.verbose(\"ExtractADALIdToken has been called\");\n    var adalIdToken = this.cacheStorage.getItem(Constants.adalIdToken);\n    return !StringUtils.isEmpty(adalIdToken) ? TokenUtils.extractIdToken(adalIdToken) : null;\n  };\n  /**\n   * @hidden\n   * Acquires access token using a hidden iframe.\n   * @ignore\n   */\n\n\n  UserAgentApplication.prototype.renewToken = function (requestSignature, resolve, reject, account, serverAuthenticationRequest) {\n    this.logger.verbose(\"RenewToken has been called\");\n    this.logger.verbosePii(\"RenewToken scope and authority: \" + requestSignature);\n    var frameName = WindowUtils.generateFrameName(FramePrefix.TOKEN_FRAME, requestSignature);\n    WindowUtils.addHiddenIFrame(frameName, this.logger);\n    this.updateCacheEntries(serverAuthenticationRequest, account, false);\n    this.logger.verbosePii(\"RenewToken expected state: \" + serverAuthenticationRequest.state); // Build urlNavigate with \"prompt=none\" and navigate to URL in hidden iFrame\n\n    var urlNavigate = UrlUtils.urlRemoveQueryStringParameter(UrlUtils.createNavigateUrl(serverAuthenticationRequest), Constants.prompt) + Constants.prompt_none + Constants.response_mode_fragment;\n    window.renewStates.push(serverAuthenticationRequest.state);\n    window.requestType = Constants.renewToken;\n    this.logger.verbose(\"Set window.renewState and requestType\");\n    this.registerCallback(serverAuthenticationRequest.state, requestSignature, resolve, reject);\n    this.logger.infoPii(\"Navigate to: \" + urlNavigate);\n    this.loadIframeTimeout(urlNavigate, frameName, requestSignature).catch(function (error) {\n      return reject(error);\n    });\n  };\n  /**\n   * @hidden\n   * Renews idtoken for app's own backend when clientId is passed as a single scope in the scopes array.\n   * @ignore\n   */\n\n\n  UserAgentApplication.prototype.renewIdToken = function (requestSignature, resolve, reject, account, serverAuthenticationRequest) {\n    this.logger.info(\"RenewIdToken has been called\");\n    var frameName = WindowUtils.generateFrameName(FramePrefix.ID_TOKEN_FRAME, requestSignature);\n    WindowUtils.addHiddenIFrame(frameName, this.logger);\n    this.updateCacheEntries(serverAuthenticationRequest, account, false);\n    this.logger.verbose(\"RenewIdToken expected state: \" + serverAuthenticationRequest.state); // Build urlNavigate with \"prompt=none\" and navigate to URL in hidden iFrame\n\n    var urlNavigate = UrlUtils.urlRemoveQueryStringParameter(UrlUtils.createNavigateUrl(serverAuthenticationRequest), Constants.prompt) + Constants.prompt_none + Constants.response_mode_fragment;\n\n    if (this.silentLogin) {\n      this.logger.verbose(\"Silent login is true, set silentAuthenticationState\");\n      window.requestType = Constants.login;\n      this.silentAuthenticationState = serverAuthenticationRequest.state;\n    } else {\n      this.logger.verbose(\"Not silent login, set window.renewState and requestType\");\n      window.requestType = Constants.renewToken;\n      window.renewStates.push(serverAuthenticationRequest.state);\n    } // note: scope here is clientId\n\n\n    this.registerCallback(serverAuthenticationRequest.state, requestSignature, resolve, reject);\n    this.logger.infoPii(\"Navigate to:\\\" \" + urlNavigate);\n    this.loadIframeTimeout(urlNavigate, frameName, requestSignature).catch(function (error) {\n      return reject(error);\n    });\n  };\n  /**\n   * @hidden\n   *\n   * This method builds an Access Token Cache item and saves it to the cache, returning the original\n   * AuthResponse augmented with a parsed expiresOn attribute.\n   *\n   * @param response The AuthResponse object that contains the token to be saved\n   * @param authority The authority under which the ID token will be cached\n   * @param scopes The scopes to be added to the cache item key (undefined for ID token cache items)\n   * @param clientInfo Client Info object that is used to generate the homeAccountIdentifier\n   * @param expiration Token expiration timestamp\n   */\n\n\n  UserAgentApplication.prototype.saveToken = function (response, authority, scopes, clientInfo, expiration) {\n    var accessTokenKey = new AccessTokenKey(authority, this.clientId, scopes, clientInfo.uid, clientInfo.utid);\n    var accessTokenValue = new AccessTokenValue(response.accessToken, response.idToken.rawIdToken, expiration.toString(), clientInfo.encodeClientInfo());\n    this.cacheStorage.setItem(JSON.stringify(accessTokenKey), JSON.stringify(accessTokenValue));\n\n    if (expiration) {\n      this.logger.verbose(\"New expiration set for token\");\n      response.expiresOn = new Date(expiration * 1000);\n    } else {\n      this.logger.error(\"Could not parse expiresIn parameter for access token\");\n    }\n\n    return response;\n  };\n  /**\n   * @hidden\n   *\n   * This method sets up the elements of an ID Token cache item and calls saveToken to save it in\n   * Access Token Cache item format for the client application to use.\n   *\n   * @param response The AuthResponse object that will be used to build the cache item\n   * @param authority The authority under which the ID token will be cached\n   * @param parameters The response's Hash Params, which contain the ID token returned from the server\n   * @param clientInfo Client Info object that is used to generate the homeAccountIdentifier\n   * @param idTokenObj ID Token object from which the ID token's expiration is extracted\n   */\n\n  /* tslint:disable:no-string-literal */\n\n\n  UserAgentApplication.prototype.saveIdToken = function (response, authority, parameters, clientInfo, idTokenObj) {\n    this.logger.verbose(\"SaveIdToken has been called\");\n\n    var idTokenResponse = __assign({}, response); // Scopes are undefined so they don't show up in ID token cache key\n\n\n    var scopes;\n    idTokenResponse.scopes = Constants.oidcScopes;\n    idTokenResponse.accessToken = parameters[ServerHashParamKeys.ID_TOKEN];\n    var expiration = Number(idTokenObj.expiration); // Set ID Token item in cache\n\n    this.logger.verbose(\"Saving ID token to cache\");\n    return this.saveToken(idTokenResponse, authority, scopes, clientInfo, expiration);\n  };\n  /**\n   * @hidden\n   *\n   * This method sets up the elements of an Access Token cache item and calls saveToken to save it to the cache\n   *\n   * @param response The AuthResponse object that will be used to build the cache item\n   * @param authority The authority under which the access token will be cached\n   * @param parameters The response's Hash Params, which contain the access token returned from the server\n   * @param clientInfo Client Info object that is used to generate the homeAccountIdentifier\n   */\n\n  /* tslint:disable:no-string-literal */\n\n\n  UserAgentApplication.prototype.saveAccessToken = function (response, authority, parameters, clientInfo) {\n    this.logger.verbose(\"SaveAccessToken has been called\");\n\n    var accessTokenResponse = __assign({}, response); // read the scopes\n\n\n    var scope = parameters[ServerHashParamKeys.SCOPE];\n    var consentedScopes = scope.split(\" \"); // retrieve all access tokens from the cache, remove the dup scopes\n\n    var accessTokenCacheItems = this.cacheStorage.getAllAccessTokens(this.clientId, authority);\n    this.logger.verbose(\"Retrieving all access tokens from cache and removing duplicates\");\n\n    for (var i = 0; i < accessTokenCacheItems.length; i++) {\n      var accessTokenCacheItem = accessTokenCacheItems[i];\n\n      if (accessTokenCacheItem.key.homeAccountIdentifier === response.account.homeAccountIdentifier) {\n        var cachedScopes = accessTokenCacheItem.key.scopes.split(\" \");\n\n        if (ScopeSet.isIntersectingScopes(cachedScopes, consentedScopes)) {\n          this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));\n        }\n      }\n    }\n\n    accessTokenResponse.accessToken = parameters[ServerHashParamKeys.ACCESS_TOKEN];\n    accessTokenResponse.scopes = consentedScopes;\n    var expiresIn = TimeUtils.parseExpiresIn(parameters[ServerHashParamKeys.EXPIRES_IN]);\n    var parsedState = RequestUtils.parseLibraryState(parameters[ServerHashParamKeys.STATE]);\n    var expiration = parsedState.ts + expiresIn;\n    this.logger.verbose(\"Saving access token to cache\");\n    return this.saveToken(accessTokenResponse, authority, scope, clientInfo, expiration);\n  };\n  /**\n   * @hidden\n   * Saves token or error received in the response from AAD in the cache. In case of id_token, it also creates the account object.\n   * @ignore\n   */\n\n\n  UserAgentApplication.prototype.saveTokenFromHash = function (hash, stateInfo) {\n    this.logger.verbose(\"SaveTokenFromHash has been called\");\n    this.logger.info(\"State status: \" + stateInfo.stateMatch + \"; Request type: \" + stateInfo.requestType);\n    var response = {\n      uniqueId: \"\",\n      tenantId: \"\",\n      tokenType: \"\",\n      idToken: null,\n      idTokenClaims: null,\n      accessToken: null,\n      scopes: [],\n      expiresOn: null,\n      account: null,\n      accountState: \"\",\n      fromCache: false\n    };\n    var error;\n    var hashParams = UrlUtils.deserializeHash(hash);\n    var authorityKey = \"\";\n    var acquireTokenAccountKey = \"\";\n    var idTokenObj = null; // If server returns an error\n\n    if (hashParams.hasOwnProperty(ServerHashParamKeys.ERROR_DESCRIPTION) || hashParams.hasOwnProperty(ServerHashParamKeys.ERROR)) {\n      this.logger.verbose(\"Server returned an error\");\n      this.logger.infoPii(\"Error : \" + hashParams[ServerHashParamKeys.ERROR] + \"; Error description: \" + hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);\n      this.cacheStorage.setItem(ErrorCacheKeys.ERROR, hashParams[ServerHashParamKeys.ERROR]);\n      this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]); // login\n\n      if (stateInfo.requestType === Constants.login) {\n        this.logger.verbose(\"RequestType is login, caching login error, generating authorityKey\");\n        this.cacheStorage.setItem(ErrorCacheKeys.LOGIN_ERROR, hashParams[ServerHashParamKeys.ERROR_DESCRIPTION] + \":\" + hashParams[ServerHashParamKeys.ERROR]);\n        authorityKey = AuthCache.generateAuthorityKey(stateInfo.state);\n      } // acquireToken\n\n\n      if (stateInfo.requestType === Constants.renewToken) {\n        this.logger.verbose(\"RequestType is renewToken, generating acquireTokenAccountKey\");\n        authorityKey = AuthCache.generateAuthorityKey(stateInfo.state);\n        var account = this.getAccount();\n        var accountId = void 0;\n\n        if (account && !StringUtils.isEmpty(account.homeAccountIdentifier)) {\n          accountId = account.homeAccountIdentifier;\n          this.logger.verbose(\"AccountId is set\");\n        } else {\n          accountId = Constants.no_account;\n          this.logger.verbose(\"AccountId is set as no_account\");\n        }\n\n        acquireTokenAccountKey = AuthCache.generateAcquireTokenAccountKey(accountId, stateInfo.state);\n      }\n\n      var hashErr = hashParams[ServerHashParamKeys.ERROR];\n      var hashErrDesc = hashParams[ServerHashParamKeys.ERROR_DESCRIPTION];\n\n      if (InteractionRequiredAuthError.isInteractionRequiredError(hashErr) || InteractionRequiredAuthError.isInteractionRequiredError(hashErrDesc)) {\n        error = new InteractionRequiredAuthError(hashParams[ServerHashParamKeys.ERROR], hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);\n      } else {\n        error = new ServerError(hashParams[ServerHashParamKeys.ERROR], hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);\n      }\n    } // If the server returns \"Success\"\n    else {\n        this.logger.verbose(\"Server returns success\"); // Verify the state from redirect and record tokens to storage if exists\n\n        if (stateInfo.stateMatch) {\n          this.logger.info(\"State is right\");\n\n          if (hashParams.hasOwnProperty(ServerHashParamKeys.SESSION_STATE)) {\n            this.logger.verbose(\"Fragment has session state, caching\");\n            this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.SESSION_STATE, stateInfo.state), hashParams[ServerHashParamKeys.SESSION_STATE]);\n          }\n\n          response.accountState = this.getAccountState(stateInfo.state);\n          var clientInfo = void 0; // Process access_token\n\n          if (hashParams.hasOwnProperty(ServerHashParamKeys.ACCESS_TOKEN)) {\n            this.logger.info(\"Fragment has access token\");\n            response.accessToken = hashParams[ServerHashParamKeys.ACCESS_TOKEN];\n\n            if (hashParams.hasOwnProperty(ServerHashParamKeys.SCOPE)) {\n              response.scopes = hashParams[ServerHashParamKeys.SCOPE].split(\" \");\n            } // retrieve the id_token from response if present\n\n\n            if (hashParams.hasOwnProperty(ServerHashParamKeys.ID_TOKEN)) {\n              this.logger.verbose(\"Fragment has id_token\");\n              idTokenObj = new IdToken(hashParams[ServerHashParamKeys.ID_TOKEN]);\n            } else {\n              this.logger.verbose(\"No idToken on fragment, getting idToken from cache\");\n              idTokenObj = new IdToken(this.cacheStorage.getItem(PersistentCacheKeys.IDTOKEN));\n            }\n\n            response = ResponseUtils.setResponseIdToken(response, idTokenObj); // set authority\n\n            var authority = this.populateAuthority(stateInfo.state, this.inCookie, this.cacheStorage, idTokenObj);\n            this.logger.verbose(\"Got authority from cache\"); // retrieve client_info - if it is not found, generate the uid and utid from idToken\n\n            if (hashParams.hasOwnProperty(ServerHashParamKeys.CLIENT_INFO)) {\n              this.logger.verbose(\"Fragment has clientInfo\");\n              clientInfo = new ClientInfo(hashParams[ServerHashParamKeys.CLIENT_INFO], authority);\n            } else if (this.authorityInstance.AuthorityType === AuthorityType.Adfs) {\n              clientInfo = ClientInfo.createClientInfoFromIdToken(idTokenObj, authority);\n            } else {\n              this.logger.warning(\"ClientInfo not received in the response from AAD\");\n            }\n\n            response.account = Account.createAccount(idTokenObj, clientInfo);\n            this.logger.verbose(\"Account object created from response\");\n            var accountKey = void 0;\n\n            if (response.account && !StringUtils.isEmpty(response.account.homeAccountIdentifier)) {\n              this.logger.verbose(\"AccountKey set\");\n              accountKey = response.account.homeAccountIdentifier;\n            } else {\n              this.logger.verbose(\"AccountKey set as no_account\");\n              accountKey = Constants.no_account;\n            }\n\n            acquireTokenAccountKey = AuthCache.generateAcquireTokenAccountKey(accountKey, stateInfo.state);\n            var acquireTokenAccountKey_noaccount = AuthCache.generateAcquireTokenAccountKey(Constants.no_account, stateInfo.state);\n            this.logger.verbose(\"AcquireTokenAccountKey generated\");\n            var cachedAccount = this.cacheStorage.getItem(acquireTokenAccountKey);\n            var acquireTokenAccount = void 0; // Check with the account in the Cache\n\n            if (!StringUtils.isEmpty(cachedAccount)) {\n              acquireTokenAccount = JSON.parse(cachedAccount);\n              this.logger.verbose(\"AcquireToken request account retrieved from cache\");\n\n              if (response.account && acquireTokenAccount && Account.compareAccounts(response.account, acquireTokenAccount)) {\n                response = this.saveAccessToken(response, authority, hashParams, clientInfo);\n                this.logger.info(\"The user object received in the response is the same as the one passed in the acquireToken request\");\n              } else {\n                this.logger.warning(\"The account object created from the response is not the same as the one passed in the acquireToken request\");\n              }\n            } else if (!StringUtils.isEmpty(this.cacheStorage.getItem(acquireTokenAccountKey_noaccount))) {\n              this.logger.verbose(\"No acquireToken account retrieved from cache\");\n              response = this.saveAccessToken(response, authority, hashParams, clientInfo);\n            }\n          } // Process id_token\n\n\n          if (hashParams.hasOwnProperty(ServerHashParamKeys.ID_TOKEN)) {\n            this.logger.info(\"Fragment has idToken\"); // set the idToken\n\n            idTokenObj = new IdToken(hashParams[ServerHashParamKeys.ID_TOKEN]); // set authority\n\n            var authority = this.populateAuthority(stateInfo.state, this.inCookie, this.cacheStorage, idTokenObj);\n            response = ResponseUtils.setResponseIdToken(response, idTokenObj);\n\n            if (hashParams.hasOwnProperty(ServerHashParamKeys.CLIENT_INFO)) {\n              this.logger.verbose(\"Fragment has clientInfo\");\n              clientInfo = new ClientInfo(hashParams[ServerHashParamKeys.CLIENT_INFO], authority);\n            } else if (this.authorityInstance.AuthorityType === AuthorityType.Adfs) {\n              clientInfo = ClientInfo.createClientInfoFromIdToken(idTokenObj, authority);\n            } else {\n              this.logger.warning(\"ClientInfo not received in the response from AAD\");\n            }\n\n            this.account = Account.createAccount(idTokenObj, clientInfo);\n            response.account = this.account;\n            this.logger.verbose(\"Account object created from response\");\n\n            if (idTokenObj && idTokenObj.nonce) {\n              this.logger.verbose(\"IdToken has nonce\"); // check nonce integrity if idToken has nonce - throw an error if not matched\n\n              var cachedNonce = this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN, stateInfo.state), this.inCookie);\n\n              if (idTokenObj.nonce !== cachedNonce) {\n                this.account = null;\n                this.cacheStorage.setItem(ErrorCacheKeys.LOGIN_ERROR, \"Nonce Mismatch. Expected Nonce: \" + cachedNonce + \",\" + \"Actual Nonce: \" + idTokenObj.nonce);\n                this.logger.error(\"Nonce Mismatch. Expected Nonce: \" + cachedNonce + \", Actual Nonce: \" + idTokenObj.nonce);\n                error = ClientAuthError.createNonceMismatchError(cachedNonce, idTokenObj.nonce);\n              } // Save the token\n              else {\n                  this.logger.verbose(\"Nonce matches, saving idToken to cache\");\n                  this.cacheStorage.setItem(PersistentCacheKeys.IDTOKEN, hashParams[ServerHashParamKeys.ID_TOKEN], this.inCookie);\n                  this.cacheStorage.setItem(PersistentCacheKeys.CLIENT_INFO, clientInfo.encodeClientInfo(), this.inCookie); // Save idToken as access token item for app itself\n\n                  this.saveIdToken(response, authority, hashParams, clientInfo, idTokenObj);\n                }\n            } else {\n              this.logger.verbose(\"No idToken or no nonce. Cache key for Authority set as state\");\n              authorityKey = stateInfo.state;\n              acquireTokenAccountKey = stateInfo.state;\n              this.logger.error(\"Invalid id_token received in the response\");\n              error = ClientAuthError.createInvalidIdTokenError(idTokenObj);\n              this.cacheStorage.setItem(ErrorCacheKeys.ERROR, error.errorCode);\n              this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, error.errorMessage);\n            }\n          }\n        } // State mismatch - unexpected/invalid state\n        else {\n            this.logger.verbose(\"State mismatch\");\n            authorityKey = stateInfo.state;\n            acquireTokenAccountKey = stateInfo.state;\n            var expectedState = this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, stateInfo.state), this.inCookie);\n            this.logger.error(\"State Mismatch. Expected State: \" + expectedState + \", Actual State: \" + stateInfo.state);\n            error = ClientAuthError.createInvalidStateError(stateInfo.state, expectedState);\n            this.cacheStorage.setItem(ErrorCacheKeys.ERROR, error.errorCode);\n            this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, error.errorMessage);\n          }\n      } // Set status to completed\n\n\n    this.cacheStorage.removeItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, stateInfo.state));\n    this.cacheStorage.resetTempCacheItems(stateInfo.state);\n    this.logger.verbose(\"Status set to complete, temporary cache cleared\"); // this is required if navigateToLoginRequestUrl=false\n\n    if (this.inCookie) {\n      this.logger.verbose(\"InCookie is true, setting authorityKey in cookie\");\n      this.cacheStorage.setItemCookie(authorityKey, \"\", -1);\n      this.cacheStorage.clearMsalCookie(stateInfo.state);\n    }\n\n    if (error) {\n      // Error case, set status to cancelled\n      throw error;\n    }\n\n    if (!response) {\n      throw AuthError.createUnexpectedError(\"Response is null\");\n    }\n\n    return response;\n  };\n  /**\n   * Set Authority when saving Token from the hash\n   * @param state\n   * @param inCookie\n   * @param cacheStorage\n   * @param idTokenObj\n   * @param response\n   */\n\n\n  UserAgentApplication.prototype.populateAuthority = function (state, inCookie, cacheStorage, idTokenObj) {\n    this.logger.verbose(\"PopulateAuthority has been called\");\n    var authorityKey = AuthCache.generateAuthorityKey(state);\n    var cachedAuthority = cacheStorage.getItem(authorityKey, inCookie); // retrieve the authority from cache and replace with tenantID\n\n    return StringUtils.isEmpty(cachedAuthority) ? cachedAuthority : UrlUtils.replaceTenantPath(cachedAuthority, idTokenObj.tenantId);\n  };\n  /* tslint:enable:no-string-literal */\n  // #endregion\n  // #region Account\n\n  /**\n   * Returns the signed in account\n   * (the account object is created at the time of successful login)\n   * or null when no state is found\n   * @returns {@link Account} - the account object stored in MSAL\n   */\n\n\n  UserAgentApplication.prototype.getAccount = function () {\n    // if a session already exists, get the account from the session\n    if (this.account) {\n      return this.account;\n    } // frame is used to get idToken and populate the account for the given session\n\n\n    var rawIdToken = this.cacheStorage.getItem(PersistentCacheKeys.IDTOKEN, this.inCookie);\n    var rawClientInfo = this.cacheStorage.getItem(PersistentCacheKeys.CLIENT_INFO, this.inCookie);\n\n    if (!StringUtils.isEmpty(rawIdToken) && !StringUtils.isEmpty(rawClientInfo)) {\n      var idToken = new IdToken(rawIdToken);\n      var clientInfo = new ClientInfo(rawClientInfo, \"\");\n      this.account = Account.createAccount(idToken, clientInfo);\n      return this.account;\n    } // if login not yet done, return null\n\n\n    return null;\n  };\n  /**\n   * @hidden\n   *\n   * Extracts state value from the accountState sent with the authentication request.\n   * @returns {string} scope.\n   * @ignore\n   */\n\n\n  UserAgentApplication.prototype.getAccountState = function (state) {\n    if (state) {\n      var splitIndex = state.indexOf(Constants.resourceDelimiter);\n\n      if (splitIndex > -1 && splitIndex + 1 < state.length) {\n        return state.substring(splitIndex + 1);\n      }\n    }\n\n    return state;\n  };\n  /**\n   * Use to get a list of unique accounts in MSAL cache based on homeAccountIdentifier.\n   *\n   * @param {@link Array<Account>} Account - all unique accounts in MSAL cache.\n   */\n\n\n  UserAgentApplication.prototype.getAllAccounts = function () {\n    var accounts = [];\n    var accessTokenCacheItems = this.cacheStorage.getAllAccessTokens(Constants.clientId, Constants.homeAccountIdentifier);\n\n    for (var i = 0; i < accessTokenCacheItems.length; i++) {\n      var idToken = new IdToken(accessTokenCacheItems[i].value.idToken);\n      var clientInfo = new ClientInfo(accessTokenCacheItems[i].value.homeAccountIdentifier, \"\");\n      var account = Account.createAccount(idToken, clientInfo);\n      accounts.push(account);\n    }\n\n    return this.getUniqueAccounts(accounts);\n  };\n  /**\n   * @hidden\n   *\n   * Used to filter accounts based on homeAccountIdentifier\n   * @param {Array<Account>}  Accounts - accounts saved in the cache\n   * @ignore\n   */\n\n\n  UserAgentApplication.prototype.getUniqueAccounts = function (accounts) {\n    if (!accounts || accounts.length <= 1) {\n      return accounts;\n    }\n\n    var flags = [];\n    var uniqueAccounts = [];\n\n    for (var index = 0; index < accounts.length; ++index) {\n      if (accounts[index].homeAccountIdentifier && flags.indexOf(accounts[index].homeAccountIdentifier) === -1) {\n        flags.push(accounts[index].homeAccountIdentifier);\n        uniqueAccounts.push(accounts[index]);\n      }\n    }\n\n    return uniqueAccounts;\n  }; // #endregion\n  // #region Angular\n\n  /**\n   * @hidden\n   *\n   * Broadcast messages - Used only for Angular?  *\n   * @param eventName\n   * @param data\n   */\n\n\n  UserAgentApplication.prototype.broadcast = function (eventName, data) {\n    var evt = new CustomEvent(eventName, {\n      detail: data\n    });\n    window.dispatchEvent(evt);\n  };\n  /**\n   * @hidden\n   *\n   * Helper function to retrieve the cached token\n   *\n   * @param scopes\n   * @param {@link Account} account\n   * @param state\n   * @return {@link AuthResponse} AuthResponse\n   */\n\n\n  UserAgentApplication.prototype.getCachedTokenInternal = function (scopes, account, state, correlationId) {\n    // Get the current session's account object\n    var accountObject = account || this.getAccount();\n\n    if (!accountObject) {\n      return null;\n    } // Construct AuthenticationRequest based on response type; set \"redirectUri\" from the \"request\" which makes this call from Angular - for this.getRedirectUri()\n\n\n    var newAuthority = this.authorityInstance ? this.authorityInstance : AuthorityFactory.CreateInstance(this.authority, this.config.auth.validateAuthority);\n    var responseType = this.getTokenType(accountObject, scopes);\n    var serverAuthenticationRequest = new ServerRequestParameters(newAuthority, this.clientId, responseType, this.getRedirectUri(), scopes, state, correlationId); // get cached token\n\n    return this.getCachedToken(serverAuthenticationRequest, account);\n  };\n  /**\n   * @hidden\n   *\n   * Get scopes for the Endpoint - Used in Angular to track protected and unprotected resources without interaction from the developer app\n   * Note: Please check if we need to set the \"redirectUri\" from the \"request\" which makes this call from Angular - for this.getRedirectUri()\n   *\n   * @param endpoint\n   */\n\n\n  UserAgentApplication.prototype.getScopesForEndpoint = function (endpoint) {\n    // if user specified list of unprotectedResources, no need to send token to these endpoints, return null.\n    if (this.config.framework.unprotectedResources.length > 0) {\n      for (var i = 0; i < this.config.framework.unprotectedResources.length; i++) {\n        if (endpoint.indexOf(this.config.framework.unprotectedResources[i]) > -1) {\n          return null;\n        }\n      }\n    } // process all protected resources and send the matched one\n\n\n    if (this.config.framework.protectedResourceMap.size > 0) {\n      for (var _i = 0, _a = Array.from(this.config.framework.protectedResourceMap.keys()); _i < _a.length; _i++) {\n        var key = _a[_i]; // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n\n        if (endpoint.indexOf(key) > -1) {\n          return this.config.framework.protectedResourceMap.get(key);\n        }\n      }\n    }\n    /*\n     * default resource will be clientid if nothing specified\n     * App will use idtoken for calls to itself\n     * check if it's staring from http or https, needs to match with app host\n     */\n\n\n    if (endpoint.indexOf(\"http://\") > -1 || endpoint.indexOf(\"https://\") > -1) {\n      if (UrlUtils.getHostFromUri(endpoint) === UrlUtils.getHostFromUri(this.getRedirectUri())) {\n        return new Array(this.clientId);\n      }\n    } else {\n      /*\n       * in angular level, the url for $http interceptor call could be relative url,\n       * if it's relative call, we'll treat it as app backend call.\n       */\n      return new Array(this.clientId);\n    } // if not the app's own backend or not a domain listed in the endpoints structure\n\n\n    return null;\n  };\n  /**\n   * Return boolean flag to developer to help inform if login is in progress\n   * @returns {boolean} true/false\n   */\n\n\n  UserAgentApplication.prototype.getLoginInProgress = function () {\n    return this.cacheStorage.isInteractionInProgress(true);\n  };\n  /**\n   * @hidden\n   * @ignore\n   *\n   * @param loginInProgress\n   */\n\n\n  UserAgentApplication.prototype.setInteractionInProgress = function (inProgress) {\n    this.cacheStorage.setInteractionInProgress(inProgress);\n  };\n  /**\n   * @hidden\n   * @ignore\n   *\n   * @param loginInProgress\n   */\n\n\n  UserAgentApplication.prototype.setloginInProgress = function (loginInProgress) {\n    this.setInteractionInProgress(loginInProgress);\n  };\n  /**\n   * @hidden\n   * @ignore\n   *\n   * returns the status of acquireTokenInProgress\n   */\n\n\n  UserAgentApplication.prototype.getAcquireTokenInProgress = function () {\n    return this.cacheStorage.isInteractionInProgress(true);\n  };\n  /**\n   * @hidden\n   * @ignore\n   *\n   * @param acquireTokenInProgress\n   */\n\n\n  UserAgentApplication.prototype.setAcquireTokenInProgress = function (acquireTokenInProgress) {\n    this.setInteractionInProgress(acquireTokenInProgress);\n  };\n  /**\n   * @hidden\n   * @ignore\n   *\n   * returns the logger handle\n   */\n\n\n  UserAgentApplication.prototype.getLogger = function () {\n    return this.logger;\n  };\n  /**\n   * Sets the logger callback.\n   * @param logger Logger callback\n   */\n\n\n  UserAgentApplication.prototype.setLogger = function (logger) {\n    this.logger = logger;\n  }; // #endregion\n  // #region Getters and Setters\n\n  /**\n   * Use to get the redirect uri configured in MSAL or null.\n   * Evaluates redirectUri if its a function, otherwise simply returns its value.\n   *\n   * @returns {string} redirect URL\n   */\n\n\n  UserAgentApplication.prototype.getRedirectUri = function (reqRedirectUri) {\n    if (reqRedirectUri) {\n      return reqRedirectUri;\n    } else if (typeof this.config.auth.redirectUri === \"function\") {\n      return this.config.auth.redirectUri();\n    }\n\n    return this.config.auth.redirectUri;\n  };\n  /**\n   * Use to get the post logout redirect uri configured in MSAL or null.\n   * Evaluates postLogoutredirectUri if its a function, otherwise simply returns its value.\n   *\n   * @returns {string} post logout redirect URL\n   */\n\n\n  UserAgentApplication.prototype.getPostLogoutRedirectUri = function () {\n    if (typeof this.config.auth.postLogoutRedirectUri === \"function\") {\n      return this.config.auth.postLogoutRedirectUri();\n    }\n\n    return this.config.auth.postLogoutRedirectUri;\n  };\n  /**\n   * Use to get the current {@link Configuration} object in MSAL\n   *\n   * @returns {@link Configuration}\n   */\n\n\n  UserAgentApplication.prototype.getCurrentConfiguration = function () {\n    if (!this.config) {\n      throw ClientConfigurationError.createNoSetConfigurationError();\n    }\n\n    return this.config;\n  };\n  /**\n   * @ignore\n   *\n   * Utils function to create the Authentication\n   * @param {@link account} account object\n   * @param scopes\n   *\n   * @returns {string} token type: token, id_token or id_token token\n   *\n   */\n\n\n  UserAgentApplication.prototype.getTokenType = function (accountObject, scopes) {\n    var accountsMatch = Account.compareAccounts(accountObject, this.getAccount());\n    return ServerRequestParameters.determineResponseType(accountsMatch, scopes);\n  };\n  /**\n   * @hidden\n   * @ignore\n   *\n   * Sets the cachekeys for and stores the account information in cache\n   * @param account\n   * @param state\n   * @hidden\n   */\n\n\n  UserAgentApplication.prototype.setAccountCache = function (account, state) {\n    // Cache acquireTokenAccountKey\n    var accountId = account ? this.getAccountId(account) : Constants.no_account;\n    var acquireTokenAccountKey = AuthCache.generateAcquireTokenAccountKey(accountId, state);\n    this.cacheStorage.setItem(acquireTokenAccountKey, JSON.stringify(account));\n  };\n  /**\n   * @hidden\n   * @ignore\n   *\n   * Sets the cacheKey for and stores the authority information in cache\n   * @param state\n   * @param authority\n   * @hidden\n   */\n\n\n  UserAgentApplication.prototype.setAuthorityCache = function (state, authority) {\n    // Cache authorityKey\n    var authorityKey = AuthCache.generateAuthorityKey(state);\n    this.cacheStorage.setItem(authorityKey, UrlUtils.CanonicalizeUri(authority), this.inCookie);\n  };\n  /**\n   * Updates account, authority, and nonce in cache\n   * @param serverAuthenticationRequest\n   * @param account\n   * @hidden\n   * @ignore\n   */\n\n\n  UserAgentApplication.prototype.updateCacheEntries = function (serverAuthenticationRequest, account, isLoginCall, loginStartPage) {\n    // Cache Request Originator Page\n    if (loginStartPage) {\n      this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.LOGIN_REQUEST, serverAuthenticationRequest.state), loginStartPage, this.inCookie);\n    } // Cache account and authority\n\n\n    if (isLoginCall) {\n      // Cache the state\n      this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, serverAuthenticationRequest.state), serverAuthenticationRequest.state, this.inCookie);\n    } else {\n      this.setAccountCache(account, serverAuthenticationRequest.state);\n    } // Cache authorityKey\n\n\n    this.setAuthorityCache(serverAuthenticationRequest.state, serverAuthenticationRequest.authority); // Cache nonce\n\n    this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN, serverAuthenticationRequest.state), serverAuthenticationRequest.nonce, this.inCookie);\n  };\n  /**\n   * Returns the unique identifier for the logged in account\n   * @param account\n   * @hidden\n   * @ignore\n   */\n\n\n  UserAgentApplication.prototype.getAccountId = function (account) {\n    // return `${account.accountIdentifier}` + Constants.resourceDelimiter + `${account.homeAccountIdentifier}`;\n    var accountId;\n\n    if (!StringUtils.isEmpty(account.homeAccountIdentifier)) {\n      accountId = account.homeAccountIdentifier;\n    } else {\n      accountId = Constants.no_account;\n    }\n\n    return accountId;\n  };\n  /**\n   * @ignore\n   * @param extraQueryParameters\n   *\n   * Construct 'tokenRequest' from the available data in adalIdToken\n   */\n\n\n  UserAgentApplication.prototype.buildIDTokenRequest = function (request) {\n    var tokenRequest = {\n      scopes: Constants.oidcScopes,\n      authority: this.authority,\n      account: this.getAccount(),\n      extraQueryParameters: request.extraQueryParameters,\n      correlationId: request.correlationId\n    };\n    return tokenRequest;\n  };\n  /**\n   * @ignore\n   * @param config\n   * @param clientId\n   *\n   * Construct TelemetryManager from Configuration\n   */\n\n\n  UserAgentApplication.prototype.getTelemetryManagerFromConfig = function (config, clientId) {\n    if (!config) {\n      // if unset\n      return TelemetryManager.getTelemetrymanagerStub(clientId, this.logger);\n    } // if set then validate\n\n\n    var applicationName = config.applicationName,\n        applicationVersion = config.applicationVersion,\n        telemetryEmitter = config.telemetryEmitter;\n\n    if (!applicationName || !applicationVersion || !telemetryEmitter) {\n      throw ClientConfigurationError.createTelemetryConfigError(config);\n    } // if valid then construct\n\n\n    var telemetryPlatform = {\n      applicationName: applicationName,\n      applicationVersion: applicationVersion\n    };\n    var telemetryManagerConfig = {\n      platform: telemetryPlatform,\n      clientId: clientId\n    };\n    return new TelemetryManager(telemetryManagerConfig, telemetryEmitter, this.logger);\n  };\n\n  return UserAgentApplication;\n}();\n\nexport { UserAgentApplication };","map":null,"metadata":{},"sourceType":"module"}